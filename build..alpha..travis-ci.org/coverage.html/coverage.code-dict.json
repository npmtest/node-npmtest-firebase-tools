{"/home/travis/build/npmtest/node-npmtest-firebase-tools/test.js":"/* istanbul instrument in package npmtest_firebase_tools */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/lib.npmtest_firebase_tools.js":"/* istanbul instrument in package npmtest_firebase_tools */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_firebase_tools = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_firebase_tools = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-firebase-tools && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_firebase_tools */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_firebase_tools\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_firebase_tools.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_firebase_tools.rollup.js'] =\n            local.assetsDict['/assets.npmtest_firebase_tools.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_firebase_tools.__dirname +\n                    '/lib.npmtest_firebase_tools.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/index.js":"'use strict';\n\nvar program = require('commander');\nvar pkg = require('./package.json');\nvar chalk = require('chalk');\nvar logger = require('./lib/logger');\nvar didYouMean = require('didyoumean');\n\nprogram.version(pkg.version);\nprogram.option('-P, --project <alias_or_project_id>', 'the Firebase project to use for this command');\nprogram.option('-j, --json', 'output JSON instead of text, also triggers non-interactive mode');\nprogram.option('--token <token>', 'supply an auth token for this command');\nprogram.option('--non-interactive', 'error out of the command instead of waiting for prompts');\nprogram.option('--interactive', 'force interactive shell treatment even when not detected');\nprogram.option('--debug', 'print verbose debug output and keep a debug log file');\n// program.option('-d, --debug', 'display debug information and keep firebase-debug.log');\n\nvar client = {};\nclient.cli = program;\nclient.logger = require('./lib/logger');\nclient.errorOut = function(error, status) {\n  require('./lib/errorOut')(client, error, status);\n};\nclient.getCommand = function(name) {\n  for (var i = 0; i < client.cli.commands.length; i++) {\n    if (client.cli.commands[i]._name === name) {\n      return client.cli.commands[i];\n    }\n  }\n  return null;\n};\n\nrequire('./commands')(client);\n\nvar commandNames = program.commands.map(function(cmd) {\n  return cmd._name;\n});\n\nvar RENAMED_COMMANDS = {\n  'delete-site': 'hosting:disable',\n  'disable:hosting': 'hosting:disable',\n  'data:get': 'database:get',\n  'data:push': 'database:push',\n  'data:remove': 'database:remove',\n  'data:set': 'database:set',\n  'data:update': 'database:update',\n  'deploy:hosting': 'deploy --only hosting',\n  'deploy:database': 'deploy --only database',\n  'prefs:token': 'login:ci'\n};\n\nprogram.action(function(cmd, cmd2) {\n  logger.error(\n    chalk.bold.red('Error:'),\n    chalk.bold(cmd), 'is not a Firebase command'\n  );\n\n  if (RENAMED_COMMANDS[cmd]) {\n    logger.error();\n    logger.error(chalk.bold(cmd) + ' has been renamed, please run', chalk.bold('firebase ' + RENAMED_COMMANDS[cmd]), 'instead');\n  } else {\n    var suggestion = didYouMean(cmd, commandNames);\n    suggestion = suggestion || didYouMean([cmd, cmd2].join(':'), commandNames);\n    if (suggestion) {\n      logger.error();\n      logger.error('Did you mean', chalk.bold(suggestion) + '?');\n    }\n  }\n\n  process.exit(1);\n});\n\nmodule.exports = client;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/logger.js":"'use strict';\n\nvar winston = require('winston');\n\nfunction expandErrors(logger) {\n  var oldLogFunc = logger.log;\n  logger.log = function() {\n    var args = Array.prototype.slice.call(arguments, 0);\n    if (args.length >= 2 && args[1] instanceof Error) {\n      args[1] = args[1].stack;\n    }\n    return oldLogFunc.apply(this, args);\n  };\n  return logger;\n}\n\nvar logger = expandErrors(new winston.Logger());\nlogger.exitOnError = false;\n\nmodule.exports = logger;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/index.js":"'use strict';\n\nmodule.exports = function(client) {\n  var loadCommand = function(name) {\n    var cmd = require('./' + name);\n    cmd.register(client);\n    return cmd.runner();\n  };\n\n  client.auth = {\n    upload: loadCommand('auth-import'),\n    export: loadCommand('auth-export')\n  };\n\n  client.database = {\n    get: loadCommand('database-get'),\n    push: loadCommand('database-push'),\n    set: loadCommand('database-set'),\n    remove: loadCommand('database-remove'),\n    update: loadCommand('database-update'),\n    profile: loadCommand('database-profile')\n  };\n\n  client.deploy = loadCommand('deploy');\n\n  client.hosting = {\n    disable: loadCommand('hosting-disable')\n  };\n\n  client.functions = {\n    log: loadCommand('functions-log'),\n    config: {\n      clone: loadCommand('functions-config-clone'),\n      get: loadCommand('functions-config-get'),\n      set: loadCommand('functions-config-set'),\n      unset: loadCommand('functions-config-unset')\n    }\n  };\n\n  client.help = loadCommand('help');\n  client.init = loadCommand('init');\n  client.list = loadCommand('list');\n\n  client.login = loadCommand('login');\n  client.login.ci = loadCommand('login-ci');\n\n  client.logout = loadCommand('logout');\n  client.open = loadCommand('open');\n  client.serve = loadCommand('serve');\n\n  client.setup = {\n    web: loadCommand('setup-web')\n  };\n\n  client.tools = {\n    migrate: loadCommand('tools-migrate')\n  };\n\n  client.use = loadCommand('use');\n\n  return client;\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/auth-import.js":"'use strict';\n\nvar RSVP = require('rsvp');\nvar csv = require('csv-streamify');\nvar chalk = require('chalk');\nvar fs = require('fs');\nvar jsonStream = require('JSONStream');\nvar _ = require('lodash');\n\nvar Command = require('../lib/command');\nvar accountImporter = require('../lib/accountImporter');\nvar getProjectId = require('../lib/getProjectId');\nvar logger = require('../lib/logger');\nvar requireAccess = require('../lib/requireAccess');\nvar utils = require('../lib/utils');\n\nvar MAX_BATCH_SIZE = 1000;\nvar validateOptions = accountImporter.validateOptions;\nvar validateUserJson = accountImporter.validateUserJson;\nvar transArrayToUser = accountImporter.transArrayToUser;\nvar serialImportUsers = accountImporter.serialImportUsers;\n\nmodule.exports = new Command('auth:import [dataFile]')\n  .description('import users into your Firebase project from a data file(.csv or .json)')\n  .option('--hash-algo <hashAlgo>', 'specify the hash algorithm used in password for these accounts')\n  .option('--hash-key <hashKey>', 'specify the key used in hash algorithm')\n  .option('--salt-separator <saltSeparator>',\n      'specify the salt separator which will be appended to salt when verifying password. only used by SCRYPT now.')\n  .option('--rounds <rounds>', 'specify how many rounds for hash calculation.')\n  .option('--mem-cost <memCost>', 'specify the memory cost for hash calculation.')\n  .before(requireAccess)\n  .action(function(dataFile, options) {\n    var projectId = getProjectId(options);\n    var checkRes = validateOptions(options);\n    if (!checkRes.valid) {\n      return checkRes;\n    }\n    var hashOptions = checkRes;\n\n    if (!_.endsWith(dataFile, '.csv') && !_.endsWith(dataFile, '.json')) {\n      return utils.reject('Data file must end with .csv or .json', {exit: 1});\n    }\n    var stats = fs.statSync(dataFile);\n    var fileSizeInBytes = stats.size;\n    logger.info('Processing ' + chalk.bold(dataFile) + ' (' + fileSizeInBytes + ' bytes)');\n\n    var inStream = fs.createReadStream(dataFile);\n    var batches = [];\n    var currentBatch = [];\n    return new RSVP.Promise(function(resolve, reject) {\n      var parser;\n      var counter = 0;\n      if (dataFile.endsWith('.csv')) {\n        parser = csv({objectMode: true});\n        parser.on('data', function(line) {\n          counter++;\n          var user = transArrayToUser(line.map(\n            function(str) {\n              // Ignore starting '|'' and trailing '|''\n              var newStr = str.trim().replace(/^[\"|'](.*)[\"|']$/, '$1');\n              return newStr === '' ? undefined : newStr;\n            }));\n          currentBatch.push(user);\n          if (currentBatch.length === MAX_BATCH_SIZE) {\n            batches.push(currentBatch);\n            currentBatch = [];\n          }\n        }).on('end', function() {\n          if (currentBatch.length) {\n            batches.push(currentBatch);\n          }\n          return resolve(batches);\n        });\n        inStream.pipe(parser);\n      } else {\n        parser = jsonStream.parse(['users', {emitKey: true}]);\n        parser.on('data', function(pair) {\n          counter++;\n          var res = validateUserJson(pair.value);\n          if (res.error) {\n            return reject(res.error);\n          }\n          currentBatch.push(pair.value);\n          if (currentBatch.length === MAX_BATCH_SIZE) {\n            batches.push(currentBatch);\n            currentBatch = [];\n          }\n        }).on('end', function() {\n          if (currentBatch.length) {\n            batches.push(currentBatch);\n          }\n          return resolve(batches);\n        });\n        inStream.pipe(parser);\n      }\n    }).then(function(userListArr) {\n      if (userListArr.length) {\n        return serialImportUsers(projectId, hashOptions, userListArr, 0);\n      }\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/command.js":"'use strict';\n\nvar RSVP = require('rsvp');\nvar _ = require('lodash');\nvar track = require('./track');\nvar logger = require('./logger');\nvar utils = require('./utils');\nvar FirebaseError = require('./error');\nvar chalk = require('chalk');\nvar getProjectId = require('./getProjectId');\nvar loadRCFile = require('./loadRCFile');\nvar Config = require('./config');\nvar detectProjectRoot = require('./detectProjectRoot');\nvar configstore = require('../lib/configstore');\n\nvar Command = function(cmd) {\n  this._cmd = cmd;\n  this._name = _.first(cmd.split(' '));\n  this._description = null;\n  this._options = [];\n  this._action = null;\n  this._befores = [];\n};\n\nCommand.prototype.description = function(description) {\n  this._description = description;\n  return this;\n};\n\nCommand.prototype.option = function() {\n  this._options.push(arguments);\n  return this;\n};\n\nCommand.prototype.before = function(fn, args) {\n  this._befores.push({\n    fn: fn,\n    args: args\n  });\n  return this;\n};\n\nCommand.prototype.action = function(fn) {\n  this._action = fn;\n  return this;\n};\n\n// ignoring this in coverage for now since it's just wrapping commander\n/* istanbul ignore next */\nCommand.prototype.register = function(client) {\n  this.client = client;\n  var program = client.cli;\n  var cmd = program.command(this._cmd);\n  if (this._description) { cmd.description(this._description); }\n  this._options.forEach(function(args) { cmd.option.apply(cmd, args); });\n\n  var self = this;\n  cmd.action(function() {\n    var runner = self.runner();\n    var start = new Date().getTime();\n    var options = _.last(_.toArray(arguments));\n    var argCount = cmd._args.length;\n    if (arguments.length - 1 > argCount) {\n      return client.errorOut(\n        new FirebaseError('Too many arguments. Run ' + chalk.bold('firebase help ' + cmd._name) + ' for usage instructions', {exit: 1})\n      );\n    }\n\n    runner.apply(self, arguments).then(function(result) {\n      if (utils.getInheritedOption(options, 'json')) {\n        console.log(JSON.stringify({\n          status: 'success',\n          result: result\n        }, null, 2));\n      }\n      var duration = new Date().getTime() - start;\n      track(self._name, 'success', duration).then(process.exit);\n    }).catch(function(err) {\n      if (utils.getInheritedOption(options, 'json')) {\n        console.log(JSON.stringify({\n          status: 'error',\n          error: err.message\n        }, null, 2));\n      }\n      var duration = Date.now() - start;\n      var errorEvent = err.exit === 1 ? 'Error (User)' : 'Error (Unexpected)';\n      var projectId = getProjectId(options, true);\n      var preppedMessage = chalk.stripColor(err.message || '').replace(projectId, '<namespace>');\n\n      RSVP.all([\n        track(self._name, 'error', duration),\n        track(errorEvent, preppedMessage, duration)\n      ]).then(function() {\n        client.errorOut(err);\n      });\n    });\n\n    return cmd;\n  });\n};\n\nCommand.prototype._prepare = function(options) {\n  options = options || {};\n  options.project = utils.getInheritedOption(options, 'project');\n\n  if (!process.stdin.isTTY || utils.getInheritedOption(options, 'nonInteractive')) {\n    options.nonInteractive = true;\n  }\n  // allow override of detected non-interactive with --interactive flag\n  if (utils.getInheritedOption(options, 'interactive')) {\n    options.nonInteractive = false;\n  }\n\n  if (utils.getInheritedOption(options, 'debug')) {\n    logger.transports.console.level = 'debug';\n  }\n  if (utils.getInheritedOption(options, 'json')) {\n    options.nonInteractive = true;\n    logger.transports.console.level = 'none';\n  }\n\n  try {\n    options.config = Config.load(options);\n  } catch (e) {\n    options.configError = e;\n  }\n\n  options.projectRoot = detectProjectRoot(options.cwd);\n  this.applyRC(options);\n  return RSVP.resolve();\n};\n\n/**\n * Apply configuration from .firebaserc files in the working directory tree.\n */\nCommand.prototype.applyRC = function(options) {\n  var rc = loadRCFile(options.cwd);\n  options.rc = rc;\n\n  options.project = options.project || (configstore.get('activeProjects') || {})[options.projectRoot];\n  // support deprecated \"firebase\" key in firebase.json\n  if (options.config && !options.project) {\n    options.project = options.config.defaults.project;\n  }\n\n  var aliases = rc.projects || {};\n  var rcProject = _.get(aliases, options.project);\n  if (rcProject) {\n    options.projectAlias = options.project;\n    options.project = rcProject;\n  } else if (!options.project && _.size(aliases) === 1) {\n    options.projectAlias = _.head(_.keys(aliases));\n    options.project = _.head(_.values(aliases));\n  }\n};\n\nCommand.prototype.runner = function() {\n  var self = this;\n  return function() {\n    var args = _.toArray(arguments);\n    // always provide at least an empty object for options\n    if (args.length === 0) {\n      args.push({});\n    }\n    var options = _.last(args);\n\n    try {\n      var befores = [self._prepare].concat(self._befores);\n      var result = befores.shift().call(self, options);\n      befores.forEach(function(before) {\n        result = result.then(function() {\n          return before.fn.call(self, options, before.args);\n        });\n      });\n      return result.then(function() {\n        return self._action.apply(self, args);\n      });\n    } catch (e) {\n      return RSVP.reject(e);\n    }\n  };\n};\n\nmodule.exports = Command;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/track.js":"'use strict';\n\nvar ua = require('universal-analytics');\nvar RSVP = require('rsvp');\n\nvar _ = require('lodash');\nvar configstore = require('./configstore');\nvar pkg = require('../package.json');\nvar uuid = require('uuid');\nvar logger = require('./logger');\n\nvar anonId = configstore.get('analytics-uuid');\nif (!anonId) {\n  anonId = uuid.v4();\n  configstore.set('analytics-uuid', anonId);\n}\n\nvar visitor = ua(process.env.FIREBASE_ANALYTICS_UA || 'UA-29174744-3', anonId, {\n  strictCidFormat: false,\n  https: true\n});\n\nmodule.exports = function(action, label, duration) {\n  return new RSVP.Promise(function(resolve) {\n    if (!_.isString(action) || !_.isString(label)) {\n      logger.debug('track received non-string arguments:', action, label);\n      resolve();\n    }\n    duration = duration || 0;\n\n    if (configstore.get('tokens') && configstore.get('usage')) {\n      visitor.event('Firebase CLI ' + pkg.version, action, label, duration).send(function() {\n        // we could handle errors here, but we won't\n        resolve();\n      });\n    } else {\n      resolve();\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/configstore.js":"'use strict';\n\nvar Configstore = require('configstore');\nvar pkg = require('../package.json');\n\n// Init a Configstore instance with an unique ID eg. package name\n// and optionally some default values\nmodule.exports = new Configstore(pkg.name);\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/utils.js":"'use strict';\n\nvar _ = require('lodash');\nvar chalk = require('chalk');\nvar Readable = require('stream').Readable;\nvar RSVP = require('rsvp');\n\nvar configstore = require('./configstore');\nvar FirebaseError = require('./error');\nvar logger = require('./logger');\n\nvar isWindows = process.platform === 'win32';\n\nmodule.exports = {\n  /**\n   * Create a Firebase Console URL for the specified path and project.\n   * @param {String} project The Project ID for the URL.\n   * @param {String} path The console path for the URL.\n   */\n  consoleUrl: function(project, path) {\n    var api = require('./api');\n    return api.consoleOrigin + '/project/' + project + path;\n  },\n  /**\n   * Trace up the ancestry of objects that have a `parent` key, finding the\n   * first instance of the provided key.\n   *\n   * @param {Object} options The options object with potential parents.\n   * @param {String} key The key for which to look.\n   */\n  getInheritedOption: function(options, key) {\n    var target = options;\n    while (target) {\n      if (_.has(target, key)) {\n        return target[key];\n      }\n      target = target.parent;\n    }\n  },\n  /**\n   * Override a value with supplied environment variable if present.\n   *\n   * @param {String} envname The environment variable to override.\n   * @param {String} value The default value if no env is set.\n   * @param {Function} coerce A function that returns the environment\n   *   variable in an acceptable format. If this throws an error, the\n   *   default value will be used.\n   * @returns {String} The fully resolved value\n   */\n  envOverride: function(envname, value, coerce) {\n    if (process.env[envname] && process.env[envname].length) {\n      if (coerce) {\n        try {\n          return coerce(process.env[envname], value);\n        } catch (e) {\n          return value;\n        }\n      }\n      return process.env[envname];\n    }\n    return value;\n  },\n\n  /**\n   * Add a subdomain to the specified HTTP origin.\n   * @param {String} origin The HTTP origin (e.g. https://example.com)\n   * @param {String} subdomain The subdomain to add\n   * @returns {String} The origin for the domain with a subdomain\n   */\n  addSubdomain: function(origin, subdomain) {\n    return origin.replace('//', '//' + subdomain + '.');\n  },\n  /**\n   * Log an info statement with a green checkmark at the start of the line.\n   * @param {String} The message to log\n   * @param {String} The log type, defaults to 'info'\n   */\n  logSuccess: function(message, type) {\n    type = type || 'info';\n    var chr = isWindows ? '+' : '✔';\n    logger[type](chalk.green(chr + ' '), message);\n  },\n  /**\n   * Log an info statement with a gray bullet at the start of the line.\n   * @param {String} The message to log\n   * @param {String} The log type, defaults to 'info'\n   */\n  logBullet: function(message, type) {\n    type = type || 'info';\n    logger[type](chalk.cyan.bold('i '), message);\n  },\n  /**\n   * Log an info statement with a gray bullet at the start of the line.\n   * @param {String} The message to log\n   * @param {String} The log type, defaults to 'info'\n   */\n  logWarning: function(message, type) {\n    type = type || 'warn';\n    var chr = isWindows ? '!' : '⚠';\n    logger[type](chalk.yellow.bold(chr + ' '), message);\n  },\n  /**\n   * Return a promise that rejects with a FirebaseError.\n   * @param {String} message the error message\n   * @param {Object} options the error options\n   */\n  reject: function(message, options) {\n    return RSVP.reject(new FirebaseError(message, options));\n  },\n  /**\n   * Print out an explanatory message if a TTY is detected for how to manage STDIN\n   */\n  explainStdin: function() {\n    if (isWindows) {\n      throw new FirebaseError('STDIN input is not available on Windows.', {exit: 1});\n    }\n    if (process.stdin.isTTY) {\n      logger.info(chalk.bold('Note:'), 'Reading STDIN. Type JSON data and then press Ctrl-D');\n    }\n  },\n  /**\n   * Convert text input to a Readable stream.\n   * @param {String} text the text to convert\n   * @returns {stream.Readable} the stream\n   */\n  stringToStream: function(text) {\n    if (!text) {\n      return undefined;\n    }\n    var s = new Readable();\n    s.push(text);\n    s.push(null);\n    return s;\n  },\n\n  /**\n   * Sets the active project alias or id in the specified directory.\n   * @param {String} projectDir the project directory\n   * @param {String} newActive the new active project alias or id\n   */\n  makeActiveProject: function(projectDir, newActive) {\n    var activeProjects = configstore.get('activeProjects') || {};\n    if (newActive) {\n      activeProjects[projectDir] = newActive;\n    } else {\n      _.unset(activeProjects, projectDir);\n    }\n\n    configstore.set('activeProjects', activeProjects);\n  },\n\n  /**\n   * Creates API endpoint string, e.g. /v1/projects/pid/cloudfunctions\n   * @param {Array} array of parts to be connected together with slashes\n   */\n  endpoint: function(parts) {\n    return '/' + _.join(parts, '/');\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/error.js":"'use strict';\n\nvar FirebaseError = function(message, options) {\n  options = options || {};\n\n  this.name = 'FirebaseError';\n  this.message = message;\n  this.children = options.children || [];\n  this.status = options.status || 500;\n  this.exit = options.exit || 1;\n  this.stack = (new Error()).stack;\n  this.original = options.original;\n  this.context = options.context;\n};\nFirebaseError.prototype = Object.create(Error.prototype);\n\nmodule.exports = FirebaseError;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/getProjectId.js":"'use strict';\n\nvar _ = require('lodash');\nvar chalk = require('chalk');\n\nvar FirebaseError = require('./error');\n\n/**\n * Tries to determine the correct app name for commands that\n * only require an app name. Uses passed in firebase option\n * first, then falls back to firebase.json.\n * @param {Object} options The command-line options object\n * @param {boolean} allowNull Whether or not the firebase flag\n * is required\n * @returns {String} The firebase name\n */\nmodule.exports = function(options, allowNull) {\n  if (!options.project && !allowNull) {\n    var aliases = _.get(options, 'rc.projects', {});\n    var aliasCount = _.size(aliases);\n\n    if (aliasCount === 0) {\n      throw new FirebaseError('No project active. Run with ' + chalk.bold('--project <projectId>') + ' or define an alias by\\nrunning ' + chalk.bold('firebase use --add'), {\n        exit: 1\n      });\n    } else {\n      var aliasList = _.map(aliases, function(projectId, aname) {\n        return '  ' + aname + ' (' + projectId + ')';\n      }).join('\\n');\n\n      throw new FirebaseError('No project active, but project aliases are available.\\n\\nRun ' + chalk.bold('firebase use <alias>') + ' with one of these options:\\n\\n' + aliasList);\n    }\n  }\n  return options.project;\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/loadRCFile.js":"'use strict';\n\nvar fsutils = require('./fsutils');\nvar path = require('path');\nvar cjson = require('cjson');\nvar utils = require('./utils');\nvar chalk = require('chalk');\nvar detectProjectRoot = require('./detectProjectRoot');\n\n/**\n * .firebaserc should always be a sibling of firebase.json. If it doesn't parse,\n * it's considered a warning, not an error.\n */\nmodule.exports = function(cwd) {\n  var out = {};\n  var dir = detectProjectRoot(cwd || process.cwd());\n  if (!dir) {\n    return out;\n  }\n\n  var potential = path.resolve(dir, './.firebaserc');\n  if (fsutils.fileExistsSync(potential)) {\n    try {\n      out = cjson.load(potential);\n    } catch (e) {\n      // a malformed .firebaserc is a warning, not an error\n      utils.logWarning('JSON parsing error while trying to load ' + chalk.bold(potential));\n    }\n  }\n  return out;\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/fsutils.js":"'use strict';\n\nvar fs = require('fs');\n\nmodule.exports = {\n  fileExistsSync: function(path) {\n    try {\n      var stats = fs.lstatSync(path);\n      return stats.isFile();\n    } catch (e) {\n      return false;\n    }\n  },\n  dirExistsSync: function(path) {\n    try {\n      var stats = fs.lstatSync(path);\n      return stats.isDirectory();\n    } catch (e) {\n      return false;\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/detectProjectRoot.js":"'use strict';\n\nvar fsutils = require('./fsutils');\nvar path = require('path');\n\nmodule.exports = function(cwd) {\n  var projectRootDir = cwd || process.cwd();\n  while (!fsutils.fileExistsSync(path.resolve(projectRootDir, './firebase.json'))) {\n    var parentDir = path.dirname(projectRootDir);\n    if (parentDir === projectRootDir) {\n      return null;\n    }\n    projectRootDir = parentDir;\n  }\n  return projectRootDir;\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/config.js":"'use strict';\n\nvar _ = require('lodash');\nvar chalk = require('chalk');\nvar cjson = require('cjson');\nvar fs = require('fs-extra');\nvar path = require('path');\nvar RSVP = require('rsvp');\n\nvar detectProjectRoot = require('./detectProjectRoot');\nvar FirebaseError = require('./error');\nvar fsutils = require('./fsutils');\nvar loadCJSON = require('./loadCJSON');\nvar parseBoltRules = require('./parseBoltRules');\nvar prompt = require('./prompt');\nvar resolveProjectPath = require('./resolveProjectPath');\nvar utils = require('./utils');\nvar validateJsonRules = require('./validateJsonRules');\nvar logger = require('./logger');\n\nvar Config = function(src, options) {\n  this.options = options || {};\n  this.projectDir = options.projectDir || detectProjectRoot(options.cwd);\n\n  this._src = src;\n  this.data = {};\n  this.defaults = {};\n  this.notes = {};\n\n  if (this._src.firebase) {\n    this.defaults.project = this._src.firebase;\n    utils.logWarning(chalk.bold('\"firebase\"') + ' key in firebase.json is deprecated. Run ' + chalk.bold('firebase use --add') + ' instead');\n  }\n\n  if (_.has(this._src, 'rules')) {\n    _.set(this._src, 'database.rules', this._src.rules);\n  }\n\n  Config.MATERIALIZE_TARGETS.forEach(function(target) {\n    if (_.get(this._src, target)) {\n      if (target === 'database.rules') {\n        _.set(this.data, 'database.rulesString', this._materialize(target));\n      } else {\n        _.set(this.data, target, this._materialize(target));\n      }\n    }\n  }, this);\n\n  // auto-detect functions from package.json in directory\n  if (this.projectDir && !this.get('functions.source') && fsutils.fileExistsSync(this.path('functions/package.json'))) {\n    this.set('functions.source', 'functions');\n  }\n\n  // use 'public' as signal for legacy hosting since it's a required key\n  if (!this.data.hosting && this._src.public) {\n    this.importLegacyHostingKeys();\n  }\n};\n\nConfig.FILENAME = 'firebase.json';\nConfig.MATERIALIZE_TARGETS = ['functions', 'hosting', 'database.rules', 'storage'];\nConfig.LEGACY_HOSTING_KEYS = ['public', 'rewrites', 'redirects', 'headers', 'ignore', 'cleanUrls', 'trailingSlash'];\n\nConfig.prototype.importLegacyHostingKeys = function() {\n  var found = false;\n  Config.LEGACY_HOSTING_KEYS.forEach(function(key) {\n    if (_.has(this._src, key)) {\n      found = true;\n      this.set('hosting.' + key, this._src[key]);\n    }\n  }, this);\n  if (found) {\n    utils.logWarning('Deprecation Warning: Firebase Hosting configuration should be moved under \"hosting\" key.');\n  }\n};\n\nConfig.prototype._hasDeepKey = function(obj, key) {\n  if (_.has(obj, key)) {\n    return true;\n  }\n\n  for (var k in obj) {\n    if (_.isPlainObject(obj[k]) && this._hasDeepKey(obj[k], key)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nConfig.prototype._materialize = function(target) {\n  var val = _.get(this._src, target);\n  if (_.isString(val)) {\n    var out = this._parseFile(target, val);\n    // if e.g. rules.json has {\"rules\": {}} use that\n    var lastSegment = _.last(target.split('.'));\n    if (_.size(out) === 1 && _.has(out, lastSegment)) {\n      out = out[lastSegment];\n    }\n    return out;\n  } else if (_.isObject(val)) {\n    if (target === 'database.rules') {\n      this.notes.databaseRules = 'inline';\n      return JSON.stringify({ 'rules': val }, null, 2);\n    }\n    return val;\n  }\n\n  throw new FirebaseError('Parse Error: \"' + target + '\" must be object or import path', {exit: 1});\n};\n\nConfig.prototype._parseFile = function(target, filePath) {\n  var fullPath = resolveProjectPath(this.options.cwd, filePath);\n  var ext = path.extname(filePath);\n  if (!fsutils.fileExistsSync(fullPath)) {\n    throw new FirebaseError('Parse Error: Imported file ' + filePath + ' does not exist', {exit: 1});\n  }\n\n  switch (ext) {\n  case '.json':\n    if (target === 'database') {\n      this.notes.databaseRules = 'json';\n    } else if (target === 'database.rules') {\n      var rules = fs.readFileSync(fullPath, 'utf8');\n      if (validateJsonRules(rules)) {\n        return rules;\n      }\n      utils.logWarning(chalk.bold.yellow('database: ') + chalk.bold(filePath) + ' must have an outer ' + chalk.bold('rules') + ' key, for example:');\n      logger.warn('\\n{\\n\\t\"rules\": {\".read\": false, \".write\": false}\\n}');\n      throw new FirebaseError('Database security rules are not correctly formatted', {exit: 1});\n    }\n    return loadCJSON(fullPath);\n  /* istanbul ignore-next */\n  case '.bolt':\n    if (target === 'database') {\n      this.notes.databaseRules = 'bolt';\n    }\n    return parseBoltRules(fullPath);\n  default:\n    throw new FirebaseError('Parse Error: ' + filePath + ' is not of a supported config file type', {exit: 1});\n  }\n};\n\nConfig.prototype.get = function(key, fallback) {\n  return _.get(this.data, key, fallback);\n};\n\nConfig.prototype.set = function(key, value) {\n  return _.set(this.data, key, value);\n};\n\nConfig.prototype.has = function(key) {\n  return _.has(this.data, key);\n};\n\nConfig.prototype.path = function(pathName) {\n  var outPath = path.normalize(path.join(this.projectDir, pathName));\n  if (_.includes(path.relative(this.projectDir, outPath), '..')) {\n    throw new FirebaseError(chalk.bold(pathName) + ' is outside of project directory', {exit: 1});\n  }\n  return outPath;\n};\n\nConfig.prototype.readProjectFile = function(p, options) {\n  try {\n    var content = fs.readFileSync(this.path(p), 'utf8');\n    if (options.json) {\n      return JSON.parse(content);\n    }\n    return content;\n  } catch (e) {\n    if (options.fallback) {\n      return options.fallback;\n    }\n    throw e;\n  }\n};\n\nConfig.prototype.writeProjectFile = function(p, content) {\n  if (typeof content !== 'string') {\n    content = JSON.stringify(content, null, 2) + '\\n';\n  }\n\n  fs.ensureFileSync(this.path(p));\n  fs.writeFileSync(this.path(p), content, 'utf8');\n};\n\nConfig.prototype.askWriteProjectFile = function(p, content) {\n  var writeTo = this.path(p);\n  var next;\n  if (fsutils.fileExistsSync(writeTo)) {\n    next = prompt.once({\n      type: 'confirm',\n      message: 'File ' + chalk.underline(p) + ' already exists. Overwrite?',\n      default: false\n    });\n  } else {\n    next = RSVP.resolve(true);\n  }\n\n  var self = this;\n  return next.then(function(result) {\n    if (result) {\n      self.writeProjectFile(p, content);\n      utils.logSuccess('Wrote ' + chalk.bold(p));\n    } else {\n      utils.logBullet('Skipping write of ' + chalk.bold(p));\n    }\n  });\n};\n\nConfig.load = function(options, allowMissing) {\n  var pd = detectProjectRoot(options.cwd);\n  if (pd) {\n    try {\n      var data = cjson.load(path.join(pd, Config.FILENAME));\n      return new Config(data, options);\n    } catch (e) {\n      throw new FirebaseError('There was an error loading firebase.json:\\n\\n' + e.message, {\n        exit: 1\n      });\n    }\n  }\n\n  if (allowMissing) {\n    return null;\n  }\n\n  throw new FirebaseError('Not in a Firebase app directory (could not locate firebase.json)', {exit: 1});\n};\n\nmodule.exports = Config;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/loadCJSON.js":"'use strict';\n\nvar FirebaseError = require('./error');\nvar cjson = require('cjson');\n\nmodule.exports = function(path) {\n  try {\n    return cjson.load(path);\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      throw new FirebaseError('File ' + path + ' does not exist', {exit: 1});\n    }\n    throw new FirebaseError('Parse Error in ' + path + ':\\n\\n' + e.message);\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/parseBoltRules.js":"'use strict';\n\nvar fs = require('fs');\nvar spawn = require('cross-spawn');\nvar FirebaseError = require('./error');\nvar chalk = require('chalk');\n\nmodule.exports = function(filename) {\n  var ruleSrc = fs.readFileSync(filename);\n\n  var result = spawn.sync('firebase-bolt', {\n    input: ruleSrc,\n    timeout: 10000,\n    encoding: 'utf-8'\n  });\n\n  if (result.error && result.error.code === 'ENOENT') {\n    throw new FirebaseError('Bolt not installed, run ' + chalk.bold('npm install -g firebase-bolt'), {exit: 1});\n  } else if (result.error) {\n    throw new FirebaseError('Unexpected error parsing Bolt rules file', {exit: 2});\n  } else if (result.status > 0) {\n    throw new FirebaseError(result.stderr, {exit: 1});\n  }\n\n  return result.stdout;\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/prompt.js":"'use strict';\n\nvar inquirer = require('inquirer');\nvar _ = require('lodash');\nvar FirebaseError = require('./error');\nvar RSVP = require('rsvp');\n\nvar prompt = function(options, questions) {\n  return new RSVP.Promise(function(resolve, reject) {\n    var prompts = [];\n    for (var i = 0; i < questions.length; i++) {\n      if (!options[questions[i].name]) {\n        prompts.push(questions[i]);\n      }\n    }\n\n    if (prompts.length && options.nonInteractive) {\n      return reject(new FirebaseError('Missing required options (' + _.uniq(_.map(prompts, 'name')).join(', ') + ') while running in non-interactive mode', {\n        children: prompts,\n        exit: 1\n      }));\n    }\n\n    return inquirer.prompt(prompts, function(answers) {\n      _.forEach(answers, function(v, k) {\n        options[k] = v;\n      });\n      return resolve(options);\n    });\n  });\n};\n\n/**\n * Allow a one-off prompt when we don't need to ask a bunch of questions.\n */\nprompt.once = function(question) {\n  question.name = question.name || 'question';\n  return prompt({}, [question]).then(function(answers) { return answers[question.name]; });\n};\n\nprompt.convertLabeledListChoices = function(choices) {\n  return choices.map(function(choice) {\n    return {checked: choice.checked, name: choice.label};\n  });\n};\n\nprompt.listLabelToValue = function(label, choices) {\n  for (var i = 0; i < choices.length; i++) {\n    if (choices[i].label === label) {\n      return choices[i].name;\n    }\n  }\n};\n\nmodule.exports = prompt;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/resolveProjectPath.js":"'use strict';\n\nvar path = require('path');\nvar detectProjectRoot = require('./detectProjectRoot');\n\nmodule.exports = function(cwd, filePath) {\n  return path.resolve(detectProjectRoot(cwd), filePath);\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/validateJsonRules.js":"'use strict';\n\nvar cjson = require('cjson');\nvar _ = require('lodash');\n\nmodule.exports = function(rules) {\n  var parsed = cjson.parse(rules);\n  return _.has(parsed, 'rules');\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/accountImporter.js":"'use strict';\n\nvar chalk = require('chalk');\nvar _ = require('lodash');\n\nvar api = require('../lib/api');\nvar logger = require('../lib/logger');\nvar utils = require('../lib/utils');\n\nvar ALLOWED_JSON_KEYS = [\n  'localId', 'email', 'emailVerified', 'passwordHash', 'salt', 'displayName', 'photoUrl', 'createdAt', 'lastSignedInAt',\n  'providerUserInfo'];\nvar ALLOWED_JSON_KEYS_RENAMING = {\n  lastSignedInAt: 'lastLoginAt'\n};\nvar ALLOWED_PROVIDER_USER_INFO_KEYS = ['providerId', 'rawId', 'email', 'displayName', 'photoUrl'];\nvar ALLOWED_PROVIDER_IDS = ['google.com', 'facebook.com', 'twitter.com', 'github.com'];\n\nvar _toWebSafeBase64 = function(data) {\n  return data.toString('base64').replace(/\\//g, '_').replace(/\\+/g, '-');\n};\n\nvar _addProviderUserInfo = function(user, providerId, arr) {\n  if (arr[0]) {\n    user.providerUserInfo.push({\n      providerId: providerId,\n      rawId: arr[0],\n      email: arr[1],\n      displayName: arr[2],\n      photoUrl: arr[3]\n    });\n  }\n};\n\nvar _genUploadAccountPostBody = function(projectId, accounts, hashOptions) {\n  var postBody = {\n    users: accounts.map(\n        function(account) {\n          if (account.passwordHash) {\n            account.passwordHash = _toWebSafeBase64(account.passwordHash);\n          }\n          if (account.salt) {\n            account.salt = _toWebSafeBase64(account.salt);\n          }\n          _.each(ALLOWED_JSON_KEYS_RENAMING, function(value, key) {\n            if (account[key]) {\n              account[value] = account[key];\n              delete account[key];\n            }\n          });\n          return account;\n        })\n  };\n  if (hashOptions.hashAlgo) {\n    postBody.hashAlgorithm = hashOptions.hashAlgo;\n  }\n  if (hashOptions.hashKey) {\n    postBody.signerKey = _toWebSafeBase64(hashOptions.hashKey);\n  }\n  if (hashOptions.saltSeparator) {\n    postBody.saltSeparator = _toWebSafeBase64(hashOptions.saltSeparator);\n  }\n  if (hashOptions.rounds) {\n    postBody.rounds = hashOptions.rounds;\n  }\n  if (hashOptions.memCost) {\n    postBody.memoryCost = hashOptions.memCost;\n  }\n  postBody.targetProjectId = projectId;\n  return postBody;\n};\n\nvar transArrayToUser = function(arr) {\n  var user = {\n    localId: arr[0],\n    email: arr[1],\n    emailVerified: arr[2] === 'true',\n    passwordHash: arr[3],\n    salt: arr[4],\n    displayName: arr[5],\n    photoUrl: arr[6],\n    createdAt: arr[23],\n    lastLoginAt: arr[24],\n    providerUserInfo: []\n  };\n  _addProviderUserInfo(user, 'google.com', arr.slice(7, 11));\n  _addProviderUserInfo(user, 'facebook.com', arr.slice(11, 15));\n  _addProviderUserInfo(user, 'twitter.com', arr.slice(15, 19));\n  _addProviderUserInfo(user, 'github.com', arr.slice(19, 23));\n  return user;\n};\n\nvar validateOptions = function(options) {\n  if (!options.hashAlgo) {\n    utils.logWarning('No hash algorithm specified. Password users cannot be imported.');\n    return {valid: true};\n  }\n  var hashAlgo = options.hashAlgo.toUpperCase();\n  switch (hashAlgo) {\n  case 'HMAC_SHA512':\n  case 'HMAC_SHA256':\n  case 'HMAC_SHA1':\n  case 'HMAC_MD5':\n    if (!options.hashKey || options.hashKey === '') {\n      return utils.reject('Must provide hash key(base64 encoded) for hash algorithm ' + options.hashAlgo, {exit: 1});\n    }\n    return {hashAlgo: hashAlgo, hashKey: options.hashKey, valid: true};\n  case 'MD5':\n  case 'SHA1':\n  case 'SHA256':\n  case 'PBKDF_SHA1':\n  case 'PBKDF2_SHA256':\n    var roundsNum = parseInt(options.rounds, 10);\n    if (isNaN(roundsNum) || roundsNum < 0 || roundsNum > 30000) {\n      return utils.reject('Must provide valid rounds(0..30000) for hash algorithm ' + options.hashAlgo, {exit: 1});\n    }\n    return {hashAlgo: hashAlgo, rounds: options.rounds, valid: true};\n  case 'SCRYPT':\n    if (!options.hashKey || options.hashKey === '') {\n      return utils.reject('Must provide hash key(base64 encoded) for hash algorithm ' + options.hashAlgo, {exit: 1});\n    }\n    roundsNum = parseInt(options.rounds, 10);\n    if (isNaN(roundsNum) || roundsNum <= 0 || roundsNum > 8) {\n      return utils.reject('Must provide valid rounds(1..8) for hash algorithm ' + options.hashAlgo, {exit: 1});\n    }\n    var memCost = parseInt(options.memCost, 10);\n    if (isNaN(memCost) || memCost <= 0 || memCost > 14) {\n      return utils.reject('Must provide valid memory cost(1..14) for hash algorithm ' + options.hashAlgo, {exit: 1});\n    }\n    var saltSeparator = '';\n    if (options.saltSeparator) {\n      saltSeparator = options.saltSeparator;\n    }\n    return {\n      hashAlgo: hashAlgo,\n      hashKey: options.hashKey,\n      saltSeparator: saltSeparator,\n      rounds: options.rounds,\n      memCost: options.memCost,\n      valid: true\n    };\n  case 'BCRYPT':\n    return {hashAlgo: hashAlgo, valid: true};\n  default:\n    return utils.reject('Unsupported hash algorithm ' + chalk.bold(options.hashAlgo));\n  }\n};\n\nvar _validateProviderUserInfo = function(providerUserInfo) {\n  if (!_.includes(ALLOWED_PROVIDER_IDS, providerUserInfo.providerId)) {\n    return {error: JSON.stringify(providerUserInfo, null, 2) + ' has unsupported providerId'};\n  }\n  var keydiff = _.difference(_.keys(providerUserInfo), ALLOWED_PROVIDER_USER_INFO_KEYS);\n  if (keydiff.length) {\n    return {error: JSON.stringify(providerUserInfo, null, 2) + ' has unsupported keys: ' + keydiff.join(',')};\n  }\n  return {};\n};\n\nvar validateUserJson = function(userJson) {\n  var keydiff = _.difference(_.keys(userJson), ALLOWED_JSON_KEYS);\n  if (keydiff.length) {\n    return {error: JSON.stringify(userJson, null, 2) + ' has unsupported keys: ' + keydiff.join(',')};\n  }\n  if (userJson.providerUserInfo) {\n    for (var i = 0; i < userJson.providerUserInfo.length; i++) {\n      var res = _validateProviderUserInfo(userJson.providerUserInfo[i]);\n      if (res.error) {\n        return res;\n      }\n    }\n  }\n  return {};\n};\n\nvar _sendRequest = function(projectId, userList, hashOptions) {\n  logger.info('Starting importing ' + userList.length + ' account(s).');\n  return api.request('POST', '/identitytoolkit/v3/relyingparty/uploadAccount', {\n    auth: true,\n    json: true,\n    data: _genUploadAccountPostBody(projectId, userList, hashOptions),\n    origin: api.googleOrigin\n  }).then(function(ret) {\n    if (ret.body.error) {\n      logger.info('Encountered problems while importing accounts. Details:');\n      logger.info(ret.body.error.map(\n          function(rawInfo) {\n            return {\n              account: JSON.stringify(userList[parseInt(rawInfo.index, 10)], null, 2),\n              reason: rawInfo.message\n            };\n          }));\n    } else {\n      utils.logSuccess('Imported successfully.');\n    }\n    logger.info();\n  });\n};\n\nvar serialImportUsers = function(projectId, hashOptions, userListArr, index) {\n  return _sendRequest(projectId, userListArr[index], hashOptions)\n      .then(function() {\n        if (index < userListArr.length - 1) {\n          return serialImportUsers(projectId, hashOptions, userListArr, index + 1);\n        }\n      });\n};\n\nvar accountImporter = {\n  validateOptions: validateOptions,\n  validateUserJson: validateUserJson,\n  transArrayToUser: transArrayToUser,\n  serialImportUsers: serialImportUsers\n};\n\nmodule.exports = accountImporter;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/api.js":"'use strict';\n\nvar request = require('request');\nvar querystring = require('querystring');\nvar FirebaseError = require('./error');\nvar RSVP = require('rsvp');\nvar _ = require('lodash');\nvar logger = require('./logger');\nvar utils = require('./utils');\nvar responseToError = require('./responseToError');\nvar refreshToken;\nvar commandScopes;\nvar scopes = require('./scopes');\nvar CLI_VERSION = require('../package.json').version;\n\nvar _request = function(options) {\n  logger.debug('>>> HTTP REQUEST',\n    options.method,\n    options.url,\n    options.body || options.form || '',\n    '\\n',\n    new Date().toString()\n  );\n\n  return new RSVP.Promise(function(resolve, reject) {\n    var req = request(options, function(err, response, body) {\n      if (err) {\n        return reject(new FirebaseError('Server Error. ' + err.message, {\n          original: err,\n          exit: 2\n        }));\n      }\n\n      logger.debug('<<< HTTP RESPONSE', response.statusCode, response.headers);\n\n      if (response.statusCode >= 400) {\n        logger.debug('<<< HTTP RESPONSE BODY', response.body);\n        if (!options.resolveOnHTTPError) {\n          return reject(responseToError(response, body, options));\n        }\n      }\n\n      return resolve({\n        status: response.statusCode,\n        response: response,\n        body: body\n      });\n    });\n\n    if (_.size(options.files) > 0) {\n      var form = req.form();\n      _.forEach(options.files, function(details, param) {\n        form.append(param, details.stream, {\n          knownLength: details.knownLength,\n          filename: details.filename,\n          contentType: details.contentType\n        });\n      });\n    }\n  });\n};\n\nvar _appendQueryData = function(path, data) {\n  if (data && _.size(data) > 0) {\n    path += _.includes(path, '?') ? '&' : '?';\n    path += querystring.stringify(data);\n  }\n  return path;\n};\n\nvar api = {\n  // \"In this context, the client secret is obviously not treated as a secret\"\n  // https://developers.google.com/identity/protocols/OAuth2InstalledApp\n  clientId: utils.envOverride('FIREBASE_CLIENT_ID', '563584335869-fgrhgmd47bqnekij5i8b5pr03ho849e6.apps.googleusercontent.com'),\n  clientSecret: utils.envOverride('FIREBASE_CLIENT_SECRET', 'j9iVZfS8kkCEFUPaAeJV0sAi'),\n  cloudloggingOrigin: utils.envOverride('FIREBASE_CLOUDLOGGING_URL', 'https://logging.googleapis.com'),\n  adminOrigin: utils.envOverride('FIREBASE_ADMIN_URL', 'https://admin.firebase.com'),\n  apikeysOrigin: utils.envOverride('FIREBASE_APIKEYS_URL', 'https://apikeys.googleapis.com'),\n  appengineOrigin: utils.envOverride('FIREBASE_APPENGINE_URL', 'https://appengine.googleapis.com'),\n  authOrigin: utils.envOverride('FIREBASE_AUTH_URL', 'https://accounts.google.com'),\n  consoleOrigin: utils.envOverride('FIREBASE_CONSOLE_URL', 'https://console.firebase.google.com'),\n  deployOrigin: utils.envOverride('FIREBASE_DEPLOY_URL', utils.envOverride('FIREBASE_UPLOAD_URL', 'https://deploy.firebase.com')),\n  firedataOrigin: utils.envOverride('FIREBASE_FIREDATA_URL', 'https://mobilesdk-pa.googleapis.com'),\n  functionsOrigin: utils.envOverride('FIREBASE_FUNCTIONS_URL', 'https://cloudfunctions.googleapis.com'),\n  googleOrigin: utils.envOverride('FIREBASE_TOKEN_URL', utils.envOverride('FIREBASE_GOOGLE_URL', 'https://www.googleapis.com')),\n  hostingOrigin: utils.envOverride('FIREBASE_HOSTING_URL', 'https://firebaseapp.com'),\n  realtimeOrigin: utils.envOverride('FIREBASE_REALTIME_URL', 'https://firebaseio.com'),\n  resourceManagerOrigin: utils.envOverride('FIREBASE_RESOURCEMANAGER_URL', 'https://cloudresourcemanager.googleapis.com'),\n  rulesOrigin: utils.envOverride('FIREBASE_RULES_URL', 'https://firebaserules.googleapis.com'),\n  runtimeconfigOrigin: utils.envOverride('FIREBASE_RUNTIMECONFIG_URL', 'https://runtimeconfig.googleapis.com'),\n\n  setToken: function(token) {\n    refreshToken = token;\n  },\n  setScopes: function(s) {\n    commandScopes = _.uniq(_.flatten([\n      scopes.EMAIL,\n      scopes.OPENID,\n      scopes.CLOUD_PROJECTS_READONLY,\n      scopes.FIREBASE_PLATFORM\n    ].concat(s || [])));\n    logger.debug('> command requires scopes:', JSON.stringify(commandScopes));\n  },\n  getAccessToken: function() {\n    return require('./auth').getAccessToken(refreshToken, commandScopes);\n  },\n  addRequestHeaders: function(reqOptions) {\n  // Runtime fetch of Auth singleton to prevent circular module dependencies\n    _.set(reqOptions, ['headers', 'User-Agent'], 'FirebaseCLI/' + CLI_VERSION);\n    var auth = require('../lib/auth');\n    return auth.getAccessToken(refreshToken, commandScopes).then(function(result) {\n      _.set(reqOptions, 'headers.authorization', 'Bearer ' + result.access_token);\n      return reqOptions;\n    });\n  },\n  request: function(method, resource, options) {\n    options = _.extend({\n      data: {},\n      origin: api.adminOrigin, // default to hitting the admin backend\n      resolveOnHTTPError: false, // by default, status codes >= 400 leads to reject\n      json: true\n    }, options);\n\n    var validMethods = ['GET', 'PUT', 'POST', 'DELETE', 'PATCH'];\n\n    if (validMethods.indexOf(method) < 0) {\n      method = 'GET';\n    }\n\n    var reqOptions = {\n      method: method\n    };\n\n    if (options.query) {\n      resource = _appendQueryData(resource, options.query);\n    }\n\n    if (method === 'GET') {\n      resource = _appendQueryData(resource, options.data);\n    } else {\n      if (_.size(options.data) > 0) {\n        reqOptions.body = options.data;\n      } else if (_.size(options.form) > 0) {\n        reqOptions.form = options.form;\n      }\n    }\n\n    reqOptions.url = options.origin + resource;\n    reqOptions.files = options.files;\n    reqOptions.resolveOnHTTPError = options.resolveOnHTTPError;\n    reqOptions.json = options.json;\n\n    if (options.auth === true) {\n      return api.addRequestHeaders(reqOptions).then(function(reqOptionsWithToken) {\n        return _request(reqOptionsWithToken);\n      });\n    }\n\n    return _request(reqOptions);\n  },\n  getProject: function(projectId) {\n    return api.request('GET', '/v1/projects/' + encodeURIComponent(projectId), {\n      auth: true\n    }).then(function(res) {\n      if (res.body && !res.body.error) {\n        return res.body;\n      }\n\n      return RSVP.reject(new FirebaseError('Server Error: Unexpected Response. Please try again', {\n        context: res,\n        exit: 2\n      }));\n    });\n  },\n  getProjects: function() {\n    return api.request('GET', '/v1/projects', {\n      auth: true\n    }).then(function(res) {\n      if (res.body && res.body.projects) {\n        return res.body.projects;\n      }\n\n      return RSVP.reject(new FirebaseError('Server Error: Unexpected Response. Please try again', {\n        context: res,\n        exit: 2\n      }));\n    });\n  }\n};\n\nmodule.exports = api;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/responseToError.js":"'use strict';\n\nvar _ = require('lodash');\nvar FirebaseError = require('./error');\n\nmodule.exports = function(response, body) {\n  if (response.statusCode < 400) {\n    return null;\n  }\n  if (!body.error) {\n    body.error = {\n      message: 'Unknown Error'\n    };\n  }\n\n  var message = 'HTTP Error: ' + response.statusCode + ', ' + (body.error.message || body.error);\n\n  var exitCode;\n  if (response.statusCode >= 500) {\n    // 5xx errors are unexpected\n    exitCode = 2;\n  } else {\n    // 4xx errors happen sometimes\n    exitCode = 1;\n  }\n\n  _.unset(response, 'request.headers');\n  return new FirebaseError(message, {\n    context: {\n      body: body,\n      response: response\n    },\n    exit: exitCode\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/scopes.js":"'use strict';\n\nmodule.exports = {\n  // default scopes\n  OPENID: 'openid',\n  EMAIL: 'email',\n  CLOUD_PROJECTS_READONLY: 'https://www.googleapis.com/auth/cloudplatformprojects.readonly',\n  FIREBASE_PLATFORM: 'https://www.googleapis.com/auth/firebase',\n\n  // incremental scopes\n  CLOUD_PLATFORM: 'https://www.googleapis.com/auth/cloud-platform',\n  CLOUD_STORAGE: 'https://www.googleapis.com/auth/devstorage.read_write',\n  CLOUD_PUBSUB: 'https://www.googleapis.com/auth/pubsub'\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/requireAccess.js":"'use strict';\n\nvar _ = require('lodash');\nvar chalk = require('chalk');\nvar RSVP = require('rsvp');\n\nvar api = require('./api');\nvar getInstanceId = require('./getInstanceId');\nvar getProjectId = require('./getProjectId');\nvar FirebaseError = require('./error');\nvar identifierToProjectId = require('./identifierToProjectId');\nvar requireAuth = require('./requireAuth');\n\nmodule.exports = function(options, authScopes) {\n  var projectId = getProjectId(options);\n  options.project = projectId;\n\n  if (process.env.FIREBASE_BYPASS_ADMIN_CALLS_FOR_TESTING === 'true') {\n    return requireAuth(options, authScopes);\n  }\n\n  return requireAuth(options, authScopes).then(function() {\n    return getInstanceId(options);\n  }).then(function(instance) {\n    options.instance = instance;\n    return api.request('GET', '/v1/database/' + options.instance + '/tokens', {auth: true});\n  }).then(function(res) {\n    options.metadataToken = res.body.metadata;\n    return;\n  }).catch(function(err) {\n    if (err && err.exit && _.get(err, 'context.body.error.code') !== 'PROJECT_NOT_FOUND') {\n      return RSVP.reject(err);\n    }\n\n    return identifierToProjectId(projectId).then(function(realProjectId) {\n      if (realProjectId) {\n        var fixCommand = 'firebase use ' + realProjectId;\n        if (options.projectAlias) {\n          fixCommand +=  ' --alias ' + options.projectAlias;\n        }\n\n        return RSVP.reject(new FirebaseError(\n          'Tried to access unrecognized project ' + chalk.bold(projectId) + ', but found matching instance for project ' + chalk.bold(realProjectId) + '.\\n\\n' +\n          'To use ' + chalk.bold(realProjectId) + ' instead, run:\\n\\n  ' +\n          chalk.bold(fixCommand)\n        ), {exit: 1});\n      }\n\n      return RSVP.reject(new FirebaseError(\n        'Unable to authorize access to project ' + chalk.bold(projectId), {exit: 1}\n      ));\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/getInstanceId.js":"'use strict';\n\nvar _ = require('lodash');\nvar api = require('./api');\nvar FirebaseError = require('./error');\n\n/**\n * Tries to determine the instance ID for the provided\n * project.\n * @param {Object} options The command-line options object\n * @returns {Promise<String>} The instance ID\n */\nmodule.exports = function(options) {\n  return api.getProject(options.project).then(function(project) {\n    if (!_.has(project, ['instances', 'database', 0])) {\n      throw new FirebaseError('No instance found for project. Please try a different project.', {\n        exit: 1\n      });\n    }\n    return project.instances.database[0];\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/identifierToProjectId.js":"'use strict';\n\nvar _ = require('lodash');\n\nvar api = require('./api');\n\nmodule.exports = function(id) {\n  return api.getProjects().then(function(projects) {\n    // if exact match for a project id, return it\n    if (_.includes(_.keys(projects), id)) {\n      return id;\n    }\n\n    for (var projectId in projects) {\n      if (projects.hasOwnProperty(projectId)) {\n        var instance = _.get(projects, [projectId, 'instances', 'database', '0']);\n        if (id === instance) {\n          return projectId;\n        }\n      }\n    }\n\n    return null;\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/requireAuth.js":"'use strict';\n\nvar _ = require('lodash');\nvar chalk = require('chalk');\nvar RSVP = require('rsvp');\n\nvar api = require('./api');\nvar configstore = require('./configstore');\nvar utils = require('./utils');\n\nmodule.exports = function(options, authScopes) {\n  var inScopes = authScopes;\n  if (_.isFunction(authScopes)) {\n    inScopes = authScopes(options);\n  }\n\n  api.setScopes(inScopes);\n  options.authScopes = api.commandScopes;\n\n  var tokens = configstore.get('tokens');\n  var user = configstore.get('user');\n\n  var tokenOpt = utils.getInheritedOption(options, 'token');\n  tokenOpt = tokenOpt || process.env.FIREBASE_TOKEN;\n\n  if (tokenOpt) {\n    api.setToken(tokenOpt);\n    return RSVP.resolve();\n  }\n\n  if (!user || !tokens) {\n    if (configstore.get('session')) {\n      return utils.reject('This version of Firebase CLI requires reauthentication.\\n\\nPlease run ' + chalk.bold('firebase login') + ' to regain access.');\n    }\n    return utils.reject('Command requires authentication, please run ' + chalk.bold('firebase login'));\n  }\n\n  options.user = user;\n  options.tokens = tokens;\n  api.setToken(tokens.refresh_token);\n  return RSVP.resolve();\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/auth-export.js":"'use strict';\n\nvar chalk = require('chalk');\nvar fs = require('fs');\nvar os = require('os');\n\nvar Command = require('../lib/command');\nvar accountExporter = require('../lib/accountExporter');\nvar getProjectId = require('../lib/getProjectId');\nvar logger = require('../lib/logger');\nvar requireAccess = require('../lib/requireAccess');\n\nvar MAX_BATCH_SIZE = 1000;\n\nvar validateOptions = accountExporter.validateOptions;\nvar serialExportUsers = accountExporter.serialExportUsers;\n\nmodule.exports = new Command('auth:export [dataFile]')\n    .description('Export accounts from your Firebase project into a data file')\n    .option(\n        '--format <format>', 'Format of exported data (csv, json). Ignored if [dataFile] has format extension.')\n    .before(requireAccess)\n    .action(function(dataFile, options) {\n      var projectId = getProjectId(options);\n      var checkRes = validateOptions(options, dataFile);\n      if (!checkRes.format) {\n        return checkRes;\n      }\n      var exportOptions = checkRes;\n      var writeStream = fs.createWriteStream(dataFile);\n      if (exportOptions.format === 'json') {\n        writeStream.write('{\"users\": [' + os.EOL);\n      }\n      exportOptions.writeStream = writeStream;\n      exportOptions.batchSize = MAX_BATCH_SIZE;\n      logger.info('Exporting accounts to ' + chalk.bold(dataFile));\n      return serialExportUsers(projectId, exportOptions).then(function() {\n        if (exportOptions.format === 'json') {\n          writeStream.write(']}');\n        }\n        writeStream.end();\n      });\n    });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/accountExporter.js":"'use strict';\n\nvar os = require('os');\nvar path = require('path');\nvar _ = require('lodash');\n\nvar api = require('../lib/api');\nvar utils = require('../lib/utils');\n\nvar EXPORTED_JSON_KEYS = [\n  'localId', 'email', 'emailVerified', 'passwordHash', 'salt', 'displayName', 'photoUrl', 'lastLoginAt', 'createdAt'];\nvar EXPORTED_JSON_KEYS_RENAMING = {\n  lastLoginAt: 'lastSignedInAt'\n};\nvar EXPORTED_PROVIDER_USER_INFO_KEYS = ['providerId', 'rawId', 'email', 'displayName', 'photoUrl'];\nvar PROVIDER_ID_INDEX_MAP = {\n  'google.com': 7,\n  'facebook.com': 11,\n  'twitter.com': 15,\n  'github.com': 19\n};\n\nvar _convertToNormalBase64 = function(data) {\n  return data.replace(/_/g, '\\/').replace(/-/g, '\\+');\n};\n\nvar _addProviderUserInfo = function(providerInfo, arr, startPos) {\n  arr[startPos] = providerInfo.rawId;\n  arr[startPos + 1] = providerInfo.email || '';\n  arr[startPos + 2] = providerInfo.displayName || '';\n  arr[startPos + 3] = providerInfo.photoUrl || '';\n};\n\nvar _transUserToArray = function(user) {\n  var arr = Array(26).fill('');\n  arr[0] = user.localId;\n  arr[1] = user.email || '';\n  arr[2] = user.emailVerified || false;\n  arr[3] = _convertToNormalBase64(user.passwordHash || '');\n  arr[4] = _convertToNormalBase64(user.salt || '');\n  arr[5] = user.displayName || '';\n  arr[6] = user.photoUrl || '';\n  for (var i = 0; i < (!user.providerUserInfo ? 0 : user.providerUserInfo.length); i++) {\n    var providerInfo = user.providerUserInfo[i];\n    if (providerInfo && PROVIDER_ID_INDEX_MAP[providerInfo.providerId]) {\n      _addProviderUserInfo(providerInfo, arr, PROVIDER_ID_INDEX_MAP[providerInfo.providerId]);\n    }\n  }\n  arr[23] = user.disabled;\n  arr[24] = user.createdAt;\n  arr[25] = user.lastLoginAt;\n  return arr;\n};\n\nvar _transUserJson = function(user) {\n  var newUser = {};\n  _.each(_.pick(user, EXPORTED_JSON_KEYS), function(value, key) {\n    var newKey = EXPORTED_JSON_KEYS_RENAMING[key] || key;\n    newUser[newKey] = value;\n  });\n  if (newUser.passwordHash) {\n    newUser.passwordHash = _convertToNormalBase64(newUser.passwordHash);\n  }\n  if (newUser.salt) {\n    newUser.salt = _convertToNormalBase64(newUser.salt);\n  }\n  if (user.providerUserInfo) {\n    newUser.providerUserInfo = [];\n    user.providerUserInfo.forEach(function(providerInfo) {\n      if (!_.includes(Object.keys(PROVIDER_ID_INDEX_MAP), providerInfo.providerId)) {\n        return;\n      }\n      newUser.providerUserInfo.push(_.pick(providerInfo, EXPORTED_PROVIDER_USER_INFO_KEYS));\n    });\n  }\n  return newUser;\n};\n\nvar validateOptions = function(options, fileName) {\n  var exportOptions = {};\n  if (fileName === undefined) {\n    return utils.reject('Must specify data file', {exit: 1});\n  }\n  var extName = path.extname(fileName.toLowerCase());\n  if (extName === '.csv') {\n    exportOptions.format = 'csv';\n  } else if (extName === '.json') {\n    exportOptions.format = 'json';\n  } else if (options.format) {\n    var format = options.format.toLowerCase();\n    if (format === 'csv' || format === 'json') {\n      exportOptions.format = format;\n    } else {\n      return utils.reject('Unsupported data file format, should be csv or json', {exit: 1});\n    }\n  } else {\n    return utils.reject('Please specify data file format in file name, or use `format` parameter', {exit: 1});\n  }\n  return exportOptions;\n};\n\nvar _writeUsersToFile = (function() {\n  var jsonSep = '';\n  return function(userList, format, writeStream) {\n    userList.map(function(user) {\n      if (user.passwordHash && user.version !== 0) {\n        // Password isn't hashed by default Scrypt.\n        delete user.passwordHash;\n        delete user.salt;\n      }\n      if (format === 'csv') {\n        writeStream.write(_transUserToArray(user).join(',') + ',' + os.EOL, 'utf8');\n      } else {\n        writeStream.write(jsonSep + JSON.stringify(_transUserJson(user), null, 2), 'utf8');\n        jsonSep = ',' + os.EOL;\n      }\n    });\n  };\n})();\n\nvar serialExportUsers = function(projectId, options) {\n  var postBody = {\n    targetProjectId: projectId,\n    maxResults: options.batchSize\n  };\n  if (options.nextPageToken) {\n    postBody.nextPageToken = options.nextPageToken;\n  }\n  return api.request('POST', '/identitytoolkit/v3/relyingparty/downloadAccount', {\n    auth: true,\n    json: true,\n    data: postBody,\n    origin: api.googleOrigin\n  }).then(function(ret) {\n    var userList = ret.body.users;\n    if (userList && userList.length > 0) {\n      _writeUsersToFile(userList, options.format, options.writeStream);\n      utils.logSuccess('Exported ' + userList.length + ' account(s) successfully.');\n      options.nextPageToken = ret.body.nextPageToken;\n      return serialExportUsers(projectId, options);\n    }\n  });\n};\n\nvar accountExporter = {\n  validateOptions: validateOptions,\n  serialExportUsers: serialExportUsers\n};\n\nmodule.exports = accountExporter;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/database-get.js":"'use strict';\n\nvar Command = require('../lib/command');\nvar requireAccess = require('../lib/requireAccess');\nvar request = require('request');\nvar api = require('../lib/api');\nvar responseToError = require('../lib/responseToError');\nvar FirebaseError = require('../lib/error');\nvar RSVP = require('rsvp');\nvar utils = require('../lib/utils');\nvar querystring = require('querystring');\nvar _ = require('lodash');\nvar fs = require('fs');\n\nvar _applyStringOpts = function(dest, src, keys, jsonKeys) {\n  _.forEach(keys, function(key) {\n    if (src[key]) {\n      dest[key] = src[key];\n    }\n  });\n\n  // some keys need JSON encoding of the querystring value\n  _.forEach(jsonKeys, function(key) {\n    var jsonVal;\n    try {\n      jsonVal = JSON.parse(src[key]);\n    } catch (e) {\n      jsonVal = src[key];\n    }\n\n    if (src[key]) {\n      dest[key] = JSON.stringify(jsonVal);\n    }\n  });\n};\n\nmodule.exports = new Command('database:get <path>')\n  .description('fetch and print JSON data at the specified path')\n  .option('-o, --output <filename>', 'save output to the specified file')\n  .option('--pretty', 'pretty print response')\n  .option('--shallow', 'return shallow response')\n  .option('--export', 'include priorities in the output response')\n  .option('--order-by <key>', 'select a child key by which to order results')\n  .option('--order-by-key', 'order by key name')\n  .option('--order-by-value', 'order by primitive value')\n  .option('--limit-to-first <num>', 'limit to the first <num> results')\n  .option('--limit-to-last <num>', 'limit to the last <num> results')\n  .option('--start-at <val>', 'start results at <val> (based on specified ordering)')\n  .option('--end-at <val>', 'end results at <val> (based on specified ordering)')\n  .option('--equal-to <val>', 'restrict results to <val> (based on specified ordering)')\n  .before(requireAccess)\n  .action(function(path, options) {\n    if (!_.startsWith(path, '/')) {\n      return utils.reject('Path must begin with /', {exit: 1});\n    }\n\n    var url = utils.addSubdomain(api.realtimeOrigin, options.instance) + path + '.json?';\n    var query = {};\n    if (options.shallow) { query.shallow = 'true'; }\n    if (options.pretty) { query.print = 'pretty'; }\n    if (options.export) { query.format = 'export'; }\n    if (options.orderByKey) { options.orderBy = '$key'; }\n    if (options.orderByValue) { options.orderBy = '$value'; }\n    _applyStringOpts(query, options, ['limitToFirst', 'limitToLast'], ['orderBy', 'startAt', 'endAt', 'equalTo']);\n\n    url += querystring.stringify(query);\n\n    var reqOptions = {\n      url: url\n    };\n\n    return api.addRequestHeaders(reqOptions).then(function(reqOptionsWithToken) {\n      return new RSVP.Promise(function(resolve, reject) {\n        var fileOut = !!options.output;\n        var outStream = fileOut ? fs.createWriteStream(options.output) : process.stdout;\n        var erroring;\n        var errorResponse = '';\n        var response;\n\n        request.get(reqOptionsWithToken)\n          .on('response', function(res) {\n            response = res;\n            if (response.statusCode >= 400) {\n              erroring = true;\n            }\n          })\n          .on('data', function(chunk) {\n            if (erroring) {\n              errorResponse += chunk;\n            } else {\n              outStream.write(chunk);\n            }\n          })\n          .on('end', function() {\n            outStream.write('\\n');\n            if (erroring) {\n              try {\n                var data = JSON.parse(errorResponse);\n                return reject(responseToError(response, data));\n              } catch (e) {\n                return reject(new FirebaseError('Malformed JSON response', {\n                  exit: 2,\n                  original: e\n                }));\n              }\n            }\n            return resolve();\n          })\n          .on('error', reject);\n      });\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/database-push.js":"'use strict';\n\nvar Command = require('../lib/command');\nvar requireAccess = require('../lib/requireAccess');\nvar request = require('request');\nvar api = require('../lib/api');\nvar responseToError = require('../lib/responseToError');\nvar FirebaseError = require('../lib/error');\nvar RSVP = require('rsvp');\nvar utils = require('../lib/utils');\nvar chalk = require('chalk');\nvar logger = require('../lib/logger');\nvar fs = require('fs');\nvar Firebase = require('firebase');\nvar _ = require('lodash');\n\nmodule.exports = new Command('database:push <path> [infile]')\n  .description('add a new JSON object to a list of data in your Firebase')\n  .option('-d, --data <data>', 'specify escaped JSON directly')\n  .before(requireAccess)\n  .action(function(path, infile, options) {\n    if (!_.startsWith(path, '/')) {\n      return utils.reject('Path must begin with /', {exit: 1});\n    }\n\n    var inStream = utils.stringToStream(options.data) || (infile ? fs.createReadStream(infile) : process.stdin);\n    var url = utils.addSubdomain(api.realtimeOrigin, options.instance) + path + '.json?';\n\n    if (!infile && !options.data) {\n      utils.explainStdin();\n    }\n\n    var reqOptions = {\n      url: url,\n      json: true\n    };\n\n    return api.addRequestHeaders(reqOptions).then(function(reqOptionsWithToken) {\n      return new RSVP.Promise(function(resolve, reject) {\n        inStream.pipe(request.post(reqOptionsWithToken, function(err, res, body) {\n          logger.info();\n          if (err) {\n            return reject(new FirebaseError('Unexpected error while pushing data', {exit: 2}));\n          } else if (res.statusCode >= 400) {\n            return reject(responseToError(res, body));\n          }\n\n          if (!_.endsWith(path, '/')) {\n            path += '/';\n          }\n\n          var consoleUrl = utils.consoleUrl(options.project, '/database/data' + path + body.name);\n          var refurl = utils.addSubdomain(api.realtimeOrigin, options.instance) + path + body.name;\n\n          utils.logSuccess('Data pushed successfully');\n          logger.info();\n          logger.info(chalk.bold('View data at:'), consoleUrl);\n          return resolve(new Firebase(refurl));\n        }));\n      });\n    });\n  });\n\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/database-set.js":"'use strict';\n\nvar Command = require('../lib/command');\nvar requireAccess = require('../lib/requireAccess');\nvar request = require('request');\nvar api = require('../lib/api');\nvar responseToError = require('../lib/responseToError');\nvar FirebaseError = require('../lib/error');\nvar RSVP = require('rsvp');\nvar utils = require('../lib/utils');\nvar chalk = require('chalk');\nvar logger = require('../lib/logger');\nvar fs = require('fs');\nvar prompt = require('../lib/prompt');\nvar _ = require('lodash');\n\nmodule.exports = new Command('database:set <path> [infile]')\n  .description('store JSON data at the specified path via STDIN, arg, or file')\n  .option('-d, --data <data>', 'specify escaped JSON directly')\n  .option('-y, --confirm', 'pass this option to bypass confirmation prompt')\n  .before(requireAccess)\n  .action(function(path, infile, options) {\n    if (!_.startsWith(path, '/')) {\n      return utils.reject('Path must begin with /', {exit: 1});\n    }\n\n    return prompt(options, [{\n      type: 'confirm',\n      name: 'confirm',\n      default: false,\n      message: 'You are about to overwrite all data at ' + chalk.cyan(utils.addSubdomain(api.realtimeOrigin, options.instance) + path) + '. Are you sure?'\n    }]).then(function() {\n      if (!options.confirm) {\n        return utils.reject('Command aborted.', {exit: 1});\n      }\n\n      var inStream = utils.stringToStream(options.data) || (infile ? fs.createReadStream(infile) : process.stdin);\n      var url = utils.addSubdomain(api.realtimeOrigin, options.instance) + path + '.json?';\n\n      if (!infile && !options.data) {\n        utils.explainStdin();\n      }\n\n      var reqOptions = {\n        url: url,\n        json: true\n      };\n\n      return api.addRequestHeaders(reqOptions).then(function(reqOptionsWithToken) {\n        return new RSVP.Promise(function(resolve, reject) {\n          inStream.pipe(request.put(reqOptionsWithToken, function(err, res, body) {\n            logger.info();\n            if (err) {\n              return reject(new FirebaseError('Unexpected error while setting data', {exit: 2}));\n            } else if (res.statusCode >= 400) {\n              return reject(responseToError(res, body));\n            }\n\n            utils.logSuccess('Data persisted successfully');\n            logger.info();\n            logger.info(chalk.bold('View data at:'), utils.consoleUrl(options.project, '/database/data' + path));\n            return resolve();\n          }));\n        });\n      });\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/database-remove.js":"'use strict';\n\nvar Command = require('../lib/command');\nvar requireAccess = require('../lib/requireAccess');\nvar request = require('request');\nvar api = require('../lib/api');\nvar responseToError = require('../lib/responseToError');\nvar FirebaseError = require('../lib/error');\nvar RSVP = require('rsvp');\nvar utils = require('../lib/utils');\nvar prompt = require('../lib/prompt');\nvar chalk = require('chalk');\nvar _ = require('lodash');\n\nmodule.exports = new Command('database:remove <path>')\n  .description('remove data from your Firebase at the specified path')\n  .option('-y, --confirm', 'pass this option to bypass confirmation prompt')\n  .before(requireAccess)\n  .action(function(path, options) {\n    if (!_.startsWith(path, '/')) {\n      return utils.reject('Path must begin with /', {exit: 1});\n    }\n\n    return prompt(options, [{\n      type: 'confirm',\n      name: 'confirm',\n      default: false,\n      message: 'You are about to remove all data at ' + chalk.cyan(utils.addSubdomain(api.realtimeOrigin, options.instance) + path) + '. Are you sure?'\n    }]).then(function() {\n      if (!options.confirm) {\n        return utils.reject('Command aborted.', {exit: 1});\n      }\n      var url = utils.addSubdomain(api.realtimeOrigin, options.instance) + path + '.json?';\n      var reqOptions = {\n        url: url,\n        json: true\n      };\n\n      return api.addRequestHeaders(reqOptions).then(function(reqOptionsWithToken) {\n        return new RSVP.Promise(function(resolve, reject) {\n          request.del(reqOptionsWithToken, function(err, res, body) {\n            if (err) {\n              return reject(new FirebaseError('Unexpected error while removing data', {exit: 2}));\n            } else if (res.statusCode >= 400) {\n              return reject(responseToError(res, body));\n            }\n\n            utils.logSuccess('Data removed successfully');\n            return resolve();\n          });\n        });\n      });\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/database-update.js":"'use strict';\n\nvar Command = require('../lib/command');\nvar requireAccess = require('../lib/requireAccess');\nvar request = require('request');\nvar api = require('../lib/api');\nvar responseToError = require('../lib/responseToError');\nvar FirebaseError = require('../lib/error');\nvar RSVP = require('rsvp');\nvar utils = require('../lib/utils');\nvar chalk = require('chalk');\nvar logger = require('../lib/logger');\nvar fs = require('fs');\nvar prompt = require('../lib/prompt');\nvar _ = require('lodash');\n\nmodule.exports = new Command('database:update <path> [infile]')\n  .description('update some of the keys for the defined path in your Firebase')\n  .option('-d, --data <data>', 'specify escaped JSON directly')\n  .option('-y, --confirm', 'pass this option to bypass confirmation prompt')\n  .before(requireAccess)\n  .action(function(path, infile, options) {\n    if (!_.startsWith(path, '/')) {\n      return utils.reject('Path must begin with /', {exit: 1});\n    }\n\n    return prompt(options, [{\n      type: 'confirm',\n      name: 'confirm',\n      default: false,\n      message: 'You are about to modify data at ' + chalk.cyan(utils.addSubdomain(api.realtimeOrigin, options.instance) + path) + '. Are you sure?'\n    }]).then(function() {\n      if (!options.confirm) {\n        return utils.reject('Command aborted.', {exit: 1});\n      }\n\n      var inStream = utils.stringToStream(options.data) || (infile ? fs.createReadStream(infile) : process.stdin);\n      var url = utils.addSubdomain(api.realtimeOrigin, options.instance) + path + '.json?';\n\n      if (!infile && !options.data) {\n        utils.explainStdin();\n      }\n\n      var reqOptions = {\n        url: url,\n        json: true\n      };\n\n      return api.addRequestHeaders(reqOptions).then(function(reqOptionsWithToken) {\n        return new RSVP.Promise(function(resolve, reject) {\n          inStream.pipe(request.patch(reqOptionsWithToken, function(err, res, body) {\n            logger.info();\n            if (err) {\n              return reject(new FirebaseError('Unexpected error while setting data', {exit: 2}));\n            } else if (res.statusCode >= 400) {\n              return reject(responseToError(res, body));\n            }\n\n            utils.logSuccess('Data updated successfully');\n            logger.info();\n            logger.info(chalk.bold('View data at:'), utils.consoleUrl(options.project, '/database/data' + path));\n            return resolve();\n          }));\n        });\n      });\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/database-profile.js":"'use strict';\n\nvar _ = require('lodash');\n\nvar Command = require('../lib/command');\nvar requireAccess = require('../lib/requireAccess');\nvar utils = require('../lib/utils');\nvar profiler = require('../lib/profiler');\n\nvar description = 'profile the Realtime Database and generate a usage report';\n\nmodule.exports = new Command('database:profile')\n  .description(description)\n  .option('-o, --output <filename>', 'save the output to the specified file')\n  .option('-d, --duration <seconds>', 'collect database usage information for the specified number of seconds')\n  .option('--raw', 'output the raw stats collected as newline delimited json')\n  .option('-i, --input <filename>', 'generate the report based on the specified file instead ' +\n                                    'of streaming logs from the database')\n  .before(requireAccess)\n  .action(function(options) {\n    // Validate options\n    if (options.raw && options.input) {\n      return utils.reject('Cannot specify both an input file and raw format', {exit: 1});\n    } else if (options.parent.json && options.raw) {\n      return utils.reject('Cannot output raw data in json format', {exit: 1});\n    } else if (options.input && _.has(options, 'duration')) {\n      return utils.reject('Cannot specify a duration for input files', {exit: 1});\n    } else if (_.has(options, 'duration') && options.duration <= 0) {\n      return utils.reject('Must specify a positive number of seconds', {exit: 1});\n    }\n\n    return profiler(options);\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/profiler.js":"'use strict';\n\nvar fs = require('fs');\nvar _ = require('lodash');\nvar ora = require('ora');\nvar readline = require('readline');\nvar request = require('request');\nvar RSVP = require('rsvp');\nvar tmp = require('tmp');\n\nvar api = require('./api');\nvar utils = require('./utils');\nvar report = require('./profileReport');\nvar FirebaseError = require('./error');\nvar responseToError = require('./responseToError');\n\nmodule.exports = function(options) {\n  var url = utils.addSubdomain(api.realtimeOrigin, options.instance) + '/.settings/profile.json?';\n\n  var rl = readline.createInterface({\n    input: process.stdin\n  });\n\n  var reqOptions = {\n    url: url,\n    headers: {\n      'Accept': 'text/event-stream'\n    }\n  };\n\n  return api.addRequestHeaders(reqOptions).then(function(reqOptionsWithToken) {\n    return new RSVP.Promise(function(resolve, reject) {\n      var fileOut = !!options.output;\n      var tmpFile = tmp.tmpNameSync();\n      var tmpStream = fs.createWriteStream(tmpFile);\n      var outStream = fileOut ? fs.createWriteStream(options.output) : process.stdout;\n      var counter = 0;\n      var spinner = ora({\n        text: '0 operations recorded. Press [enter] to stop',\n        color: 'yellow'\n      });\n      var outputFormat = options.raw ? 'RAW' : options.parent.json ? 'JSON' : 'TXT'; // eslint-disable-line no-nested-ternary\n      var erroring;\n      var errorResponse = '';\n      var response;\n\n      var generateReport = _.once(function() {\n        rl.close();\n        spinner.stop();\n        if (erroring) {\n          fs.unlinkSync(tmpFile);\n          try {\n            var data = JSON.parse(errorResponse);\n            return reject(responseToError(response, data));\n          } catch (e) {\n            return reject(new FirebaseError('Malformed JSON response', {\n              exit: 2,\n              original: e\n            }));\n          }\n        } else if (response) {\n          response.destroy();\n          response = null;\n        }\n        var reportOptions = {\n          format: outputFormat,\n          isFile: fileOut,\n          isInput: !!options.input\n        };\n        report(options.input || tmpFile, outStream, reportOptions).then(function(result) {\n          fs.unlinkSync(tmpFile);\n          resolve(result);\n        }, function(e) {\n          reject(e);\n        });\n      });\n\n      if (options.input) {\n        // If there is input, don't contact the server\n        return generateReport();\n      }\n\n      request.get(reqOptionsWithToken)\n        .on('response', function(res) {\n          response = res;\n          if (response.statusCode >= 400) {\n            erroring = true;\n          } else if (!_.has(options, 'duration')) {\n            spinner.start();\n          }\n        })\n        .on('data', function(chunk) {\n          if (erroring) {\n            errorResponse += chunk.toString();\n            return;\n          }\n          tmpStream.write(chunk);\n          if (chunk.toString().indexOf('event: log') >= 0) {\n            counter++;\n            spinner.text = counter + ' operations recorded. Press [enter] to stop';\n          }\n        })\n        .on('end', function() {\n          spinner.text = counter + ' operations recorded.\\n';\n          generateReport();\n        })\n        .on('error', function() {\n          spinner.text = counter + ' operations recorded.\\n';\n          erroring = true;\n          generateReport();\n        });\n\n      if (_.has(options, 'duration')) {\n        setTimeout(generateReport, options.duration * 1000);\n      } else {\n        // On newline, generate the report.\n        rl.question('', generateReport);\n      }\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/profileReport.js":"'use strict';\n\nvar chalk = require('chalk');\nvar Table = require('cli-table');\nvar Set = require('es6-set');\nvar fs = require('fs');\nvar _ = require('lodash');\nvar readline = require('readline');\nvar RSVP = require('rsvp');\n\nvar FirebaseError = require('./error');\nvar logger = require('./logger');\nvar utils = require('./utils');\n\nvar DATA_LINE_REGEX = /^data: /;\n\nvar BANDWIDTH_NOTE = 'NOTE: Bandwidth is an estimate and' +\n' not a valid measure of your bandwidth bill.';\n\nvar SPEED_NOTE = 'NOTE: Speeds are reported at millisecond resolution and' +\n' are not the latencies that clients will see.';\n\nvar COLLAPSE_THRESHOLD = 25;\nvar COLLAPSE_WILDCARD = ['$wildcard'];\n\nfunction extractJSON(line, input) {\n  if (!input && !DATA_LINE_REGEX.test(line)) {\n    return null;\n  } else if (!input) {\n    line = line.substring(5);\n  }\n  try {\n    return JSON.parse(line);\n  } catch (e) {\n    return null;\n  }\n}\n\nfunction pathString(path) {\n  if (path) {\n    return '/' + path.join('/');\n  }\n  return null;\n}\n\nfunction collectUnindexed(data, path, unindexed) {\n  if (!data.unIndexed) {\n    return;\n  }\n  if (!_.has(unindexed, path)) {\n    unindexed[path] = {};\n  }\n  var pathNode = unindexed[path];\n  // There is only ever one query.\n  var query = data.querySet[0];\n  // Get a unique string for this query.\n  var index = JSON.stringify(query.index);\n  if (!_.has(pathNode, index)) {\n    pathNode[index] = {\n      times: 0,\n      query: query\n    };\n  }\n  var indexNode = pathNode[index];\n  indexNode.times += 1;\n}\n\nfunction collectSpeed(data, path, opType) {\n  if (!_.has(opType, path)) {\n    opType[path] = {\n      times: 0,\n      millis: 0,\n      rejected: 0\n    };\n  }\n  var node = opType[path];\n  node.times += 1;\n  node.millis += data.millis;\n  // Explictly check for false, in case its not defined.\n  if (data.allowed === false) {\n    node.rejected += 1;\n  }\n}\n\nfunction collectBandwidth(bytes, path, direction) {\n  if (!_.has(direction, path)) {\n    direction[path] = {\n      times: 0,\n      bytes: 0\n    };\n  }\n  var node = direction[path];\n  node.times += 1;\n  node.bytes += bytes;\n}\n\nfunction collect(data, path, bytes, speed, direction) {\n  collectSpeed(data, path, speed);\n  collectBandwidth(bytes, path, direction);\n}\n\nfunction processOperation(data, state) {\n  var path = pathString(data.path);\n  state.opCount++;\n  switch (data.name) {\n  case 'concurrent-connect':\n    break;\n  case 'concurrent-disconnect':\n    break;\n  case 'realtime-read':\n    collect(data, path, data.bytes, state.readSpeed, state.outband);\n    break;\n  case 'realtime-write':\n    collect(data, path, data.bytes, state.writeSpeed, state.inband);\n    break;\n  case 'realtime-transaction':\n    collect(data, path, data.bytes, state.writeSpeed, state.inband);\n    break;\n  case 'realtime-update':\n    collect(data, path, data.bytes, state.writeSpeed, state.inband);\n    break;\n  case 'listener-listen':\n    collect(data, path, data.bytes, state.readSpeed, state.outband);\n    collectUnindexed(data, path, state.unindexed);\n    break;\n  case 'listener-broadcast':\n    collect(data, path, data.bytes, state.broadcastSpeed, state.outband);\n    break;\n  case 'listener-unlisten':\n    break;\n  case 'rest-read':\n    collect(data, path, data.bytes, state.readSpeed, state.outband);\n    break;\n  case 'rest-write':\n    collect(data, path, data.bytes, state.writeSpeed, state.inband);\n    break;\n  case 'rest-update':\n    collect(data, path, data.bytes, state.writeSpeed, state.inband);\n    break;\n  default:\n    break;\n  }\n}\n\nfunction formatNumber(num) {\n  var parts = num.toFixed(2).split('.');\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n  if (+parts[1] === 0) {\n    return parts[0];\n  }\n  return parts.join('.');\n}\n\nfunction formatBytes(bytes) {\n  var threshold = 1000;\n  if (Math.round(bytes) < threshold) {\n    return bytes + ' B';\n  }\n  var units = ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n  var u = -1;\n  var formattedBytes = bytes;\n  do {\n    formattedBytes /= threshold;\n    u++;\n  } while (Math.abs(formattedBytes) >= threshold && u < units.length - 1);\n  return formatNumber(formattedBytes) + ' ' + units[u];\n}\n\n/**\n * Takes an object with keys that are paths and combines the\n * keys that have similar prefixes.\n * Combining is done via the combiner function.\n */\nfunction collapsePaths(pathedObject, combiner, pathIndex) {\n  if (_.isUndefined(pathIndex)) {\n    pathIndex = 1;\n  }\n  var allSegments = _.keys(pathedObject).map(function(path) {\n    return path.split('/').filter(function(s) {\n      return s !== '';\n    });\n  });\n  var pathSegments = allSegments.filter(function(segments) {\n    return segments.length > pathIndex;\n  });\n  var otherSegments = allSegments.filter(function(segments) {\n    return segments.length <= pathIndex;\n  });\n  if (pathSegments.length === 0) {\n    return pathedObject;\n  }\n  var prefixes = {};\n  // Count path prefixes for the index.\n  pathSegments.forEach(function(segments) {\n    var prefixPath = pathString(segments.slice(0, pathIndex));\n    var prefixCount = _.get(prefixes, prefixPath, new Set());\n    prefixes[prefixPath] = prefixCount.add(segments[pathIndex]);\n  });\n  var collapsedObject = {};\n  pathSegments.forEach(function(segments) {\n    var prefix = segments.slice(0, pathIndex);\n    var prefixPath = pathString(prefix);\n    var prefixCount = _.get(prefixes, prefixPath);\n    var originalPath = pathString(segments);\n    if (prefixCount.size >= COLLAPSE_THRESHOLD) {\n      var tail = segments.slice(pathIndex + 1);\n      var collapsedPath = pathString(prefix.concat(COLLAPSE_WILDCARD).concat(tail));\n      var currentValue = collapsedObject[collapsedPath];\n      if (currentValue) {\n        collapsedObject[collapsedPath] = combiner(currentValue, pathedObject[originalPath]);\n      } else {\n        collapsedObject[collapsedPath] = pathedObject[originalPath];\n      }\n    } else {\n      collapsedObject[originalPath] = pathedObject[originalPath];\n    }\n  });\n  otherSegments.forEach(function(segments) {\n    var originalPath = pathString(segments);\n    collapsedObject[originalPath] = pathedObject[originalPath];\n  });\n  // Do this again, but down a level.\n  return collapsePaths(collapsedObject, combiner, pathIndex + 1);\n}\n\nfunction extractReadableIndex(query) {\n  var indexPath = _.get(query, 'index.path');\n  if (indexPath) {\n    return pathString(indexPath);\n  }\n  return '.value';\n}\n\nfunction renderUnindexedData(state, style) {\n  var table = new Table({\n    head: ['Path', 'Index', 'Count'],\n    style: {\n      head: style ? ['yellow'] : [],\n      border: style ? ['grey'] : []\n    }\n  });\n  var unindexed = collapsePaths(state.unindexed, function(u1, u2) {\n    _.mergeWith(u1, u2, function(p1, p2) {\n      return {\n        times: p1.times + p2.times,\n        query: p1.query\n      };\n    });\n  });\n  var paths = _.keys(unindexed);\n  paths.forEach(function(path) {\n    var indices = _.keys(unindexed[path]);\n    indices.forEach(function(index) {\n      var data = unindexed[path][index];\n      var row = [\n        path,\n        extractReadableIndex(data.query),\n        formatNumber(data.times)\n      ];\n      table.push(row);\n    });\n  });\n  return table;\n}\n\nfunction renderBandwidth(pureData, style) {\n  var table = new Table({\n    head: ['Path', 'Total', 'Count', 'Average'],\n    style: {\n      head: style ? ['yellow'] : [],\n      border: style ? ['grey'] : []\n    }\n  });\n  var data = collapsePaths(pureData, function(b1, b2) {\n    return {\n      bytes: b1.bytes + b2.bytes,\n      times: b1.times + b2.times\n    };\n  });\n  var paths = _.keys(data);\n  paths = _.orderBy(paths, function(path) {\n    var bandwidth = data[path];\n    return bandwidth.bytes;\n  }, ['desc']);\n  paths.forEach(function(path) {\n    var bandwidth = data[path];\n    var row = [\n      path,\n      formatBytes(bandwidth.bytes),\n      formatNumber(bandwidth.times),\n      formatBytes(bandwidth.bytes / bandwidth.times)\n    ];\n    table.push(row);\n  });\n  return table;\n}\n\nfunction renderOutgoingBandwidth(state, style) {\n  return renderBandwidth(state.outband, style);\n}\n\nfunction renderIncomingBandwidth(state, style) {\n  return renderBandwidth(state.inband, style);\n}\n\nfunction renderOperationSpeed(pureData, style, hasSecurity) {\n  var head = ['Path', 'Count', 'Average'];\n  if (hasSecurity) {\n    head.push('Permission Denied');\n  }\n  var table = new Table({\n    head: head,\n    style: {\n      head: style ? ['yellow'] : [],\n      border: style ? ['grey'] : []\n    }\n  });\n  var data = collapsePaths(pureData, function(s1, s2) {\n    return {\n      times: s1.times + s2.times,\n      millis: s1.millis + s2.millis,\n      rejected: s1.rejected + s2.rejected\n    };\n  });\n  var paths = _.keys(data);\n  paths = _.orderBy(paths, function(path) {\n    var speed = data[path];\n    return speed.millis / speed.times;\n  }, ['desc']);\n  paths.forEach(function(path) {\n    var speed = data[path];\n    var row = [\n      path,\n      speed.times,\n      formatNumber(speed.millis / speed.times) + ' ms'\n    ];\n    if (hasSecurity) {\n      row.push(formatNumber(speed.rejected));\n    }\n    table.push(row);\n  });\n  return table;\n}\n\nfunction renderWriteSpeed(state, style) {\n  return renderOperationSpeed(state.writeSpeed, style, true);\n}\n\nfunction renderReadSpeed(state, style) {\n  return renderOperationSpeed(state.readSpeed, style, true);\n}\n\nfunction renderBroadcastSpeed(state, style) {\n  return renderOperationSpeed(state.broadcastSpeed, style, false);\n}\n\nfunction reporter(tmpFile, outStream, options, onLine, onClose) {\n  var isFile = options.isFile;\n  return new RSVP.Promise(function(resolve, reject) {\n    var rl = readline.createInterface({\n      input: fs.createReadStream(tmpFile)\n    });\n    var errored = false;\n    rl.on('line', function(line) {\n      var data = extractJSON(line, options.isInput);\n      if (!data) {\n        return;\n      }\n      onLine(data);\n    });\n    rl.on('close', function() {\n      if (errored) {\n        reject(new FirebaseError('There was an error creating the report.'));\n      } else {\n        var result = onClose();\n        if (isFile) {\n          // Only resolve once the data is flushed.\n          outStream.on('finish', function() {\n            resolve(result);\n          });\n          outStream.end();\n        } else {\n          resolve(result);\n        }\n      }\n    });\n    rl.on('error', function() {\n      reject();\n    });\n    outStream.on('error', function() {\n      errored = true;\n      rl.close();\n    });\n  });\n}\n\nvar generateReport = function(tmpFile, outStream, options) {\n  var isFile = options.isFile;\n  var write = function(data) {\n    if (isFile) {\n      outStream.write(data);\n    } else {\n      logger.info(data);\n    }\n  };\n  if (options.format === 'TXT' || options.format === 'JSON') {\n    var state = {\n      outband: {},\n      inband: {},\n      writeSpeed: {},\n      broadcastSpeed: {},\n      readSpeed: {},\n      unindexed: {},\n      startTime: 0,\n      endTime: 0,\n      opCount: 0\n    };\n    return reporter(tmpFile, outStream, options, function(data) {\n      if (!state.startTime) {\n        state.startTime = data.timestamp;\n      }\n      state.endTime = data.timestamp;\n      processOperation(data, state);\n    }, function() {\n      var totalTime = state.endTime - state.startTime;\n      if (options.format === 'JSON') {\n        var tableToJson = function(table, note) {\n          var json = {\n            legend: table.options.head,\n            data: []\n          };\n          if (note) {\n            json.note = note;\n          }\n          table.forEach(function(row) {\n            json.data.push(row);\n          });\n          return json;\n        };\n        var json = {\n          totalTime: totalTime,\n          readSpeed: tableToJson(renderReadSpeed(state, !isFile), SPEED_NOTE),\n          writeSpeed: tableToJson(renderWriteSpeed(state, !isFile), SPEED_NOTE),\n          broadcastSpeed: tableToJson(renderBroadcastSpeed(state, !isFile), SPEED_NOTE),\n          downloadedBytes: tableToJson(renderOutgoingBandwidth(state, !isFile), BANDWIDTH_NOTE),\n          uploadedBytes: tableToJson(renderIncomingBandwidth(state, !isFile), BANDWIDTH_NOTE),\n          unindexedQueries: tableToJson(renderUnindexedData(state, !isFile))\n        };\n        write(JSON.stringify(json, null, 2));\n        if (isFile) {\n          return outStream.path;\n        }\n        return json;\n      }\n      var writeTitle = function(title) {\n        if (isFile) {\n          write(title + '\\n');\n        } else {\n          write(chalk.bold.yellow(title) + '\\n');\n        }\n      };\n      var writeTable = function(title, table) {\n        writeTitle(title);\n        write(table.toString() + '\\n');\n      };\n      writeTitle('Report operations collected over ' + totalTime + ' ms.');\n      writeTitle('Speed Report\\n');\n      write(SPEED_NOTE + '\\n\\n');\n      writeTable('Read Speed', renderReadSpeed(state, !isFile));\n      writeTable('Write Speed', renderWriteSpeed(state, !isFile));\n      writeTable('Broadcast Speed', renderBroadcastSpeed(state, !isFile));\n      writeTitle('Bandwidth Report\\n');\n      write(BANDWIDTH_NOTE + '\\n\\n');\n      writeTable('Downloaded Bytes', renderOutgoingBandwidth(state, !isFile));\n      writeTable('Uploaded Bytes', renderIncomingBandwidth(state, !isFile));\n      writeTable('Unindexed Queries', renderUnindexedData(state, !isFile));\n    });\n  } else if (options.format === 'RAW') {\n    return reporter(tmpFile, outStream, options, function(data) {\n      // Just write the json to the output\n      write(JSON.stringify(data) + '\\n');\n    }, function() {\n      return null;\n    });\n  }\n  return utils.reject(new FirebaseError('Invalid report format expected \"TXT\", \"JSON\", or \"RAW\"', {\n    exit: 1\n  }));\n};\n\ngenerateReport.BANDWIDTH_NOTE = BANDWIDTH_NOTE;\ngenerateReport.SPEED_NOTE = SPEED_NOTE;\ngenerateReport.helpers = {\n  collapsePaths: collapsePaths,\n  extractReadableIndex: extractReadableIndex,\n  formatNumber: formatNumber\n};\n\nmodule.exports = generateReport;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/deploy.js":"'use strict';\n\nvar _ = require('lodash');\n\nvar acquireRefs = require('../lib/acquireRefs');\nvar chalk = require('chalk');\nvar checkDupHostingKeys = require('../lib/checkDupHostingKeys');\nvar Command = require('../lib/command');\nvar deploy = require('../lib/deploy');\nvar logger = require('../lib/logger');\nvar requireConfig = require('../lib/requireConfig');\nvar scopes = require('../lib/scopes');\nvar utils = require('../lib/utils');\n\n// in order of least time-consuming to most time-consuming\nvar VALID_TARGETS = ['database', 'storage', 'functions', 'hosting'];\n\nmodule.exports = new Command('deploy')\n  .description('deploy code and assets to your Firebase project')\n  .option('-p, --public <path>', 'override the Hosting public directory specified in firebase.json')\n  .option('-m, --message <message>', 'an optional message describing this deploy')\n  .option('--only <targets>', 'only deploy to specified, comma-separated targets (e.g. \"hosting,storage\")')\n  .option('--except <targets>', 'deploy to all targets except specified (e.g. \"database\")')\n  .before(requireConfig)\n  .before(function(options) {\n    return acquireRefs(options, [scopes.CLOUD_PLATFORM])\n      .catch(function(err) {\n        if (options.config.has('functions')) {\n          throw err;\n        }\n\n        logger.info();\n        utils.logWarning(chalk.bold('Your CLI authentication needs to be updated to take advantage of new features.'));\n        utils.logWarning(chalk.bold('Please run ' + chalk.underline('firebase login --reauth')));\n        logger.info();\n\n        return acquireRefs(options, []);\n      });\n  })\n  .before(checkDupHostingKeys)\n  .action(function(options) {\n    var targets = VALID_TARGETS.filter(function(t) {\n      return options.config.has(t);\n    });\n    if (options.only && options.except) {\n      return utils.reject('Cannot specify both --only and --except', {exit: 1});\n    }\n\n    if (options.only) {\n      targets = _.intersection(targets, options.only.split(','));\n    } else if (options.except) {\n      targets = _.difference(targets, options.except.split(','));\n    }\n\n    if (targets.length === 0) {\n      return utils.reject('No deploy targets found. Valid targets: ' + VALID_TARGETS.join(','), {exit: 1});\n    }\n\n    return deploy(targets, options);\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/acquireRefs.js":"'use strict';\n\nvar FirebaseError = require('./error');\nvar api = require('./api');\nvar Firebase = require('firebase');\nvar RSVP = require('rsvp');\nvar utils = require('./utils');\nvar requireAccess = require('./requireAccess');\n\nmodule.exports = function(options, authScopes) {\n  return requireAccess(options, authScopes).then(function() {\n    return new RSVP.Promise(function(resolve, reject) {\n      if (process.env.FIREBASE_BYPASS_ADMIN_CALLS_FOR_TESTING === 'true') {\n        // requireAccess() hasn't set the metadataToken, so can't auth.\n        resolve();\n      }\n\n      var firebaseRef = new Firebase(utils.addSubdomain(api.realtimeOrigin, 'firebase'));\n      firebaseRef.authWithCustomToken(options.metadataToken, function(err) {\n        if (err) {\n          return reject(new FirebaseError('Failed to authenticate to Firebase', {\n            original: err\n          }));\n        }\n        options.firebaseRef = firebaseRef;\n        resolve();\n      });\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/checkDupHostingKeys.js":"'use strict';\n\nvar _ = require('lodash');\nvar RSVP = require('rsvp');\nvar utils = require('./utils');\nvar chalk = require('chalk');\nvar Config = require('./config');\nvar FirebaseError = require('./error');\nvar logger = require('./logger');\n\nmodule.exports = function(options) {\n  return new RSVP.Promise(function(resolve, reject) {\n    var src = options.config._src;\n    var legacyKeys = Config.LEGACY_HOSTING_KEYS;\n\n    var hasLegacyKeys = _.reduce(legacyKeys, function(result, key) {\n      return result || _.has(src, key);\n    }, false);\n\n\n    if (hasLegacyKeys && _.has(src, ['hosting'])) {\n      utils.logWarning(chalk.bold.yellow('hosting: ') + 'We found a ' + chalk.bold('hosting') + ' key inside ' + chalk.bold('firebase.json') + ' as well as hosting configuration keys that are not nested inside the ' + chalk.bold('hosting') + ' key.');\n      logger.info('\\n\\nPlease run ' + chalk.bold('firebase tools:migrate') + ' to fix this issue.');\n      logger.info('Please note that this will overwrite any configuration keys nested inside the ' + chalk.bold('hosting') + ' key with configuration keys at the root level of ' + chalk.bold('firebase.json.'));\n      reject(new FirebaseError('Hosting key and legacy hosting keys are both present in firebase.json.'));\n    } else {\n      resolve();\n    }\n  });\n};\n\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/deploy/index.js":"'use strict';\n\nvar RSVP = require('rsvp');\nvar logger = require('../logger');\nvar api = require('../api');\nvar chalk = require('chalk');\nvar _ = require('lodash');\nvar getProjectId = require('../getProjectId');\nvar utils = require('../utils');\nvar FirebaseError = require('../error');\nvar track = require('../track');\n\nvar TARGETS = {\n  hosting: require('./hosting'),\n  database: require('./database'),\n  functions: require('./functions'),\n  storage: require('./storage')\n};\n\nvar _chain = function(fns, context, options, payload) {\n  var latest = (fns.shift() || RSVP.resolve)(context, options, payload);\n  if (fns.length) {\n    return latest.then(function() {\n      return _chain(fns, context, options, payload);\n    });\n  }\n\n  return latest;\n};\n\n/**\n * The `deploy()` function runs through a three step deploy process for a listed\n * number of deploy targets. This allows deploys to be done all together or\n * for individual deployable elements to be deployed as such.\n */\nvar deploy = function(targetNames, options) {\n  var projectId = getProjectId(options);\n  var payload = {};\n  // a shared context object for deploy targets to decorate as needed\n  var context = {projectId: projectId};\n  var prepares = [];\n  var deploys = [];\n  var releases = [];\n\n  for (var i = 0; i < targetNames.length; i++) {\n    var targetName = targetNames[i];\n    var target = TARGETS[targetName];\n\n    if (!target) {\n      return RSVP.reject(new FirebaseError(chalk.bold(targetName) + ' is not a valid deploy target', {exit: 1}));\n    }\n\n    if (target.prepare) {\n      prepares.push(target.prepare);\n    }\n    if (target.deploy) {\n      deploys.push(target.deploy);\n    }\n    if (target.release) {\n      releases.push(target.release);\n    }\n  }\n\n  logger.info();\n  logger.info(chalk.bold(chalk.gray('===') + ' Deploying to \\'' + projectId +  '\\'...'));\n  logger.info();\n\n  utils.logBullet('deploying ' + chalk.bold(targetNames.join(', ')));\n\n  return _chain(prepares, context, options, payload).then(function() {\n    return _chain(deploys, context, options, payload);\n  }).then(function() {\n    utils.logBullet('starting release process (may take several minutes)...');\n    return _chain(releases, context, options, payload);\n  }).then(function() {\n    // skip talking to deploy server if only deploying functions\n    if (_.isEqual(targetNames, ['functions'])) {\n      return {body: {}};\n    }\n\n    return api.request('POST', '/v1/projects/' + encodeURIComponent(projectId) + '/releases', {\n      data: payload,\n      auth: true,\n      origin: api.deployOrigin\n    });\n  }).then(function(res) {\n    if (_.has(options, 'config.notes.databaseRules')) {\n      track('Rules Deploy', options.config.notes.databaseRules);\n    }\n\n    logger.info();\n    utils.logSuccess(chalk.underline.bold('Deploy complete!'));\n    logger.info();\n    var deployedHosting = _.includes(targetNames, 'hosting');\n    logger.info(chalk.bold('Project Console:'), utils.consoleUrl(options.project, '/overview'));\n    if (deployedHosting) {\n      logger.info(chalk.bold('Hosting URL:'), utils.addSubdomain(api.hostingOrigin, options.instance));\n    }\n    _.forEach(context.functionUrls, function(elem) {\n      logger.info(chalk.bold('Function URL'), '(' + elem.funcName + '):', elem.url);\n    });\n    return res.body;\n  });\n};\n\ndeploy.TARGETS = TARGETS;\n\nmodule.exports = deploy;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/deploy/hosting/index.js":"'use strict';\n\nmodule.exports = {\n  prepare: require('./prepare'),\n  deploy: require('./deploy')\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/deploy/hosting/prepare.js":"'use strict';\n\nvar _ = require('lodash');\nvar RSVP = require('rsvp');\nvar resolveProjectPath = require('../../resolveProjectPath');\nvar fsutils = require('../../fsutils');\nvar utils = require('../../utils');\n\nmodule.exports = function(context, options, payload) {\n  context.hosting = {\n    // TODO: Get Firebase subdomain - not always the same as the projectId\n    versionRef: options.firebaseRef.child('hosting/versions').child(options.instance).push()\n  };\n  context.hosting.versionId = context.hosting.versionRef.key();\n\n  // Allow the public directory to be overridden by the --public flag\n  if (options.public) {\n    // trigger legacy key import since public may not exist in firebase.json\n    options.config.importLegacyHostingKeys();\n    options.config.set('hosting.public', options.public);\n  }\n\n  payload.hosting = options.config.get('hosting');\n\n  if (payload.hosting) {\n    if (!_.has(payload, 'hosting.public')) {\n      return utils.reject('No public directory specified, can\\'t deploy hosting', {exit: 1});\n    } else if (!fsutils.dirExistsSync(resolveProjectPath(options.cwd, payload.hosting.public))) {\n      return utils.reject('Specified public directory does not exist, can\\'t deploy hosting', {exit: 1});\n    }\n  }\n\n  return RSVP.resolve();\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/deploy/hosting/deploy.js":"'use strict';\n\nvar _ = require('lodash');\nvar chalk = require('chalk');\nvar fs = require('fs-extra');\nvar ProgressBar = require('progress');\nvar RSVP = require('rsvp');\n\nvar api = require('../../api');\nvar logger = require('../../logger');\nvar FirebaseError = require('../../error');\nvar prepareUpload = require('../../prepareUpload');\nvar utils = require('../../utils');\n\nmodule.exports = function(context, options, payload) {\n  var local = context.hosting;\n\n  if (!payload.hosting) {\n    return RSVP.resolve();\n  }\n\n  utils.logBullet(chalk.cyan.bold('hosting:') + ' preparing ' + chalk.bold(payload.hosting.public) + ' directory for upload...');\n  return prepareUpload(options, payload.hosting).then(function(upload) {\n    if (!upload.foundIndex) {\n      utils.logWarning(chalk.bold('Warning:') + ' Public directory does not contain index.html');\n    }\n\n    if (!upload.manifest.length) {\n      return utils.reject('Must have at least one file in public directory to deploy.', {exit: 1});\n    }\n\n    _.assign(payload.hosting, {\n      version: local.versionId,\n      prefix: local.versionId + '/',\n      manifest: [] // manifest is currently unused, saving payload size\n\n      // manifest: upload.manifest.map(function(file) {\n      //   return {path: file, object: file};\n      // })\n    });\n\n    return new RSVP.Promise(function(resolve, reject) {\n      var lastCount = 0;\n      var lastPercent = 0;\n      var bar;\n      if (!options.nonInteractive && process.stderr) {\n        bar = new ProgressBar(chalk.bold('Uploading:') + ' [:bar] :percent', {\n          total: upload.manifest.length,\n          width: 40,\n          complete: chalk.green('='),\n          incomplete: ' ',\n          clear: true\n        });\n      } else {\n        process.stdout.write(chalk.cyan.bold('\\ni') + chalk.bold('  Progress: ['));\n      }\n\n      local.versionRef.on('value', function(snap) {\n        var status = snap.child('status').val();\n        switch (status) {\n        case 'deploying':\n          var uc = snap.child('uploadedCount').val() || 0;\n          var percent = Math.round(100.0 * uc / upload.manifest.length);\n          if (bar) {\n            bar.tick(uc - lastCount);\n          } else {\n            process.stdout.write(_.repeat(chalk.green('.'), percent - lastPercent));\n            lastPercent = percent;\n          }\n          lastCount = uc;\n          break;\n        case 'deployed':\n          if (bar) {\n            bar.terminate();\n          } else {\n            process.stdout.write(chalk.bold(']') + '\\n\\n');\n          }\n          utils.logSuccess(chalk.green.bold('hosting:') + ' ' + upload.manifest.length + ' files uploaded successfully');\n          local.versionRef.off('value');\n          resolve();\n          break;\n        case 'removed':\n          reject(new FirebaseError('Not Implemented', {\n            exit: 2,\n            context: snap.val()\n          }));\n          break;\n        case null:\n          break;\n        default:\n          var msg = 'File upload failed';\n          if (snap.hasChild('statusMessage')) {\n            msg += ': ' + snap.child('statusMessage').val();\n          }\n\n          reject(new FirebaseError(msg, {\n            exit: 2,\n            context: snap.val()\n          }));\n        }\n      });\n\n      api.request('PUT', '/v1/hosting/' + options.instance + '/uploads/' + local.versionId, {\n        auth: true,\n        query: {\n          fileCount: upload.manifest.length,\n          message: options.message\n        },\n        files: {\n          site: {\n            filename: 'site.tar.gz',\n            stream: upload.stream,\n            contentType: 'application/x-gzip',\n            knownLength: upload.size\n          }\n        },\n        origin: api.deployOrigin\n      }).then(function() {\n        logger.debug('[hosting] .tgz uploaded successfully, waiting for extraction');\n        fs.removeSync(upload.file);\n      }).catch(reject);\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/prepareUpload.js":"'use strict';\n\nvar fstreamIgnore = require('fstream-ignore');\nvar path = require('path');\nvar FirebaseError = require('./error');\nvar tarPack = require('tar').Pack;\nvar zlib = require('zlib');\nvar tmp = require('tmp');\nvar fs = require('fs');\nvar RSVP = require('rsvp');\n\nmodule.exports = function(options) {\n  var hostingConfig = options.config.get('hosting');\n  return new RSVP.Promise(function(resolve, reject) {\n    var publicDir = options.config.path(hostingConfig.public);\n    var indexPath = path.join(publicDir, 'index.html');\n\n    var manifest = [];\n    var foundIndex = false;\n\n    var zipStream = zlib.createGzip();\n    var tmpFile = tmp.fileSync({prefix: 'firebase-upload-', postfix: '.tar.gz'});\n\n    var fileStream = fs.createWriteStream(tmpFile.name, {\n      flags: 'w',\n      defaultEncoding: 'binary'\n    });\n\n    fileStream.on('finish', function() {\n      var stats = fs.statSync(tmpFile.name);\n\n      resolve({\n        file: tmpFile.name,\n        stream: fs.createReadStream(tmpFile.name),\n        manifest: manifest,\n        foundIndex: foundIndex,\n        size: stats.size\n      });\n    });\n\n    var reader = fstreamIgnore({\n      path: publicDir,\n      type: 'Directory',\n      follow: true,\n      filter: function() {\n        if (this.type !== 'Directory') {\n          manifest.push(path.relative(publicDir, this.path));\n        }\n        if (this.path === indexPath) {\n          foundIndex = true;\n        }\n        return true;\n      }\n    });\n\n    // we must ignore this or weird things happen if\n    // you're in the public dir when you deploy\n    reader.addIgnoreRules(['firebase-debug.log']);\n    reader.addIgnoreRules(hostingConfig.ignore || []);\n\n    reader.on('error', function(err) {\n      reject(new FirebaseError('Could not read public directory. Remove links and shortcuts and try again.', {\n        original: err,\n        exit: 1\n      }));\n    });\n\n    reader.pipe(tarPack()).pipe(zipStream).pipe(fileStream);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/deploy/database/index.js":"'use strict';\n\nmodule.exports = {\n  prepare: require('./prepare')\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/deploy/database/prepare.js":"'use strict';\n\nvar RSVP = require('rsvp');\nvar utils = require('../../utils');\nvar chalk = require('chalk');\n\nmodule.exports = function(context, options, payload) {\n  payload.database = {rulesString: options.config.get('database.rulesString')};\n  utils.logSuccess(chalk.green.bold('database:') + ' rules ready to deploy.');\n  return RSVP.resolve();\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/deploy/functions/index.js":"'use strict';\n\nmodule.exports = {\n  prepare: require('./prepare'),\n  deploy: require('./deploy'),\n  release: require('./release')\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/deploy/functions/prepare.js":"'use strict';\n\nvar _ = require('lodash');\nvar cjson = require('cjson');\nvar chalk = require('chalk');\nvar path = require('path');\nvar RSVP = require('rsvp');\n\nvar ensureApiEnabled = require('../../ensureApiEnabled').ensure;\nvar functionsConfig = require('../../functionsConfig');\nvar fsutils = require('../../fsutils');\nvar getProjectId = require('../../getProjectId');\nvar logger = require('../../logger');\nvar resolveProjectPath = require('../../resolveProjectPath');\nvar utils = require('../../utils');\n\nvar VALID_FUNCTION_NAME_REGEX = /^[a-z][a-zA-Z0-9_-]{1,62}$/i;\n\nmodule.exports = function(context, options, payload) {\n  if (!options.config.has('functions')) {\n    return RSVP.resolve();\n  }\n\n  var sourceDirName = options.config.get('functions.source');\n\n  if (!fsutils.dirExistsSync(resolveProjectPath(options.cwd, sourceDirName))) {\n    var msg = 'could not deploy functions because the ' + chalk.bold('\"' + sourceDirName + '\"') +\n      ' directory was not found. Please create it or specify a different source directory in firebase.json';\n\n    return utils.reject(msg, {exit: 1});\n  }\n\n  // Function name validation\n  var invalidNames = _.reject(_.keys(payload.functions), function(name) {\n    return _.startsWith(name, '.') || VALID_FUNCTION_NAME_REGEX.test(name);\n  });\n  if (!_.isEmpty(invalidNames)) {\n    return utils.reject(invalidNames.join(', ') + ' function name(s) must be a valid subdomain (lowercase letters, numbers and dashes)', {exit: 1});\n  }\n\n  // Check main file specified in package.json is present\n  var sourceDir = options.config.path(sourceDirName);\n  var packageJsonFile = path.join(sourceDir, 'package.json');\n  if (fsutils.fileExistsSync(packageJsonFile)) {\n    try {\n      var data = cjson.load(packageJsonFile);\n      logger.debug('> [functions] package.json contents:', JSON.stringify(data, null, 2));\n      var indexJsFile = path.join(sourceDir, data.main || 'index.js');\n      if (!fsutils.fileExistsSync(indexJsFile)) {\n        return utils.reject(path.relative(options.config.projectDir, indexJsFile) + ' does not exist, can\\'t deploy Firebase Functions', {exit: 1});\n      }\n    } catch (e) {\n      return utils.reject('There was an error reading ' + sourceDirName + path.sep + 'package.json:\\n\\n' + e.message, {exit: 1});\n    }\n  } else if (!fsutils.fileExistsSync(path.join(sourceDir, 'function.js'))) {\n    return utils.reject('No npm package found in functions source directory. Please run \\'npm init\\' inside ' + sourceDirName, {exit: 1});\n  }\n  var projectId = getProjectId(options);\n  var instance = options.instance;\n  return RSVP.all([\n    ensureApiEnabled(options.project, 'cloudfunctions.googleapis.com', 'functions'),\n    ensureApiEnabled(projectId, 'runtimeconfig.googleapis.com', 'runtimeconfig')\n  ]).then(function() {\n    return functionsConfig.getFirebaseConfig(projectId, instance);\n  }).then(function(result) {\n    _.set(context, 'firebaseConfig', result);\n    _.set(context, 'functionsBucket', 'staging.' + result.storageBucket);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/ensureApiEnabled.js":"'use strict';\n\nvar _ = require('lodash');\nvar chalk = require('chalk');\nvar RSVP = require('rsvp');\n\nvar api = require('./api');\nvar utils = require('./utils');\n\nvar POLL_INTERVAL = 10000; // 10 seconds\nvar POLLS_BEFORE_RETRY = 12; // Retry enabling the API after 2 minutes\nvar _enableApiWithRetries;\n\nvar _checkEnabled = function(projectId, apiName, prefix) {\n  return api.request('GET', '/v1/services/' + apiName + '/projectSettings/' + projectId + '?view=CONSUMER_VIEW', {\n    auth: true,\n    origin: 'https://servicemanagement.googleapis.com'\n  }).then(function(response) {\n    var isEnabled = _.get(response.body, 'usageSettings.consumerEnableStatus') === 'ENABLED';\n    if (isEnabled) {\n      utils.logSuccess(chalk.bold.green(prefix + ':') + ' all necessary APIs are enabled');\n    }\n    return isEnabled;\n  });\n};\n\nvar _enableApi = function(projectId, apiName) {\n  return api.request('PATCH', '/v1/services/' + apiName + '/projectSettings/' + projectId + '?updateMask=usageSettings', {\n    auth: true,\n    data: {\n      usageSettings: {consumerEnableStatus: 'ENABLED'}\n    },\n    origin: 'https://servicemanagement.googleapis.com'\n  });\n};\n\nvar _pollCheckEnabled = function(projectId, apiName, prefix, enablementRetries, pollRetries) {\n  pollRetries = pollRetries || 0;\n  if (pollRetries > POLLS_BEFORE_RETRY) {\n    return _enableApiWithRetries(projectId, apiName, prefix, enablementRetries + 1);\n  }\n\n  return new RSVP.Promise(function(resolve) {\n    setTimeout(function() { resolve(); }, POLL_INTERVAL);\n  }).then(function() {\n    return _checkEnabled(projectId, apiName, prefix).then(function(isEnabled) {\n      if (isEnabled) {\n        return true;\n      }\n      utils.logBullet(chalk.bold.cyan(prefix + ':') + ' waiting for APIs to activate...');\n      return _pollCheckEnabled(projectId, apiName, prefix, enablementRetries, pollRetries + 1);\n    });\n  });\n};\n\n_enableApiWithRetries = function(projectId, apiName, prefix, enablementRetries) {\n  enablementRetries = enablementRetries || 0;\n  if (enablementRetries > 1) {\n    return utils.reject('Timed out waiting for APIs to enable. Please try again in a few minutes.');\n  }\n  return _enableApi(projectId, apiName, prefix, enablementRetries).then(function() {\n    return _pollCheckEnabled(projectId, apiName, prefix, enablementRetries);\n  });\n};\n\nvar _ensureApi = function(projectId, apiName, prefix) {\n  utils.logBullet(chalk.bold.cyan(prefix + ':') + ' ensuring necessary APIs are enabled...');\n  return _checkEnabled(projectId, apiName, prefix).then(function(isEnabled) {\n    if (isEnabled) {\n      return true;\n    }\n\n    utils.logWarning(chalk.bold.yellow(prefix + ':') + ' missing necessary APIs. Enabling now...');\n    return _enableApiWithRetries(projectId, apiName, prefix);\n  });\n};\n\nmodule.exports = {\n  ensure: _ensureApi,\n  enable: _enableApi\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/functionsConfig.js":"'use strict';\n\nvar _ = require('lodash');\nvar RSVP = require('rsvp');\nvar chalk = require('chalk');\nvar api = require('./api');\nvar FirebaseError = require('./error');\nvar runtimeconfig = require('./gcp/runtimeconfig');\nvar storage = require('./gcp/storage');\nvar apikeys = require('./gcp/apikeys');\nvar getProjectId = require('./getProjectId');\nvar ensureApiEnabled = require('./ensureApiEnabled').ensure;\nvar utils = require('./utils');\n\nexports.RESERVED_NAMESPACES = ['firebase'];\n\nvar _keyToIds = function(key) {\n  var keyParts = key.split('.');\n  var variable = keyParts.slice(1).join('/');\n  return {\n    config: keyParts[0],\n    variable: variable\n  };\n};\n\nvar _setVariable = function(projectId, configId, varPath, val) {\n  if (configId === '' || varPath === '') {\n    var msg = 'Invalid argument, each config value must have a 2-part key (e.g. foo.bar).';\n    throw new FirebaseError(msg);\n  }\n  return runtimeconfig.variables.set(projectId, configId, varPath, val);\n};\n\nexports.ensureApi = function(options) {\n  var projectId = getProjectId(options);\n  return ensureApiEnabled(projectId, 'runtimeconfig.googleapis.com', 'runtimeconfig');\n};\n\nexports.varNameToIds = function(varName) {\n  return {\n    config: varName.match(new RegExp('/configs/(.+)/variables/'))[1],\n    variable: varName.match(new RegExp('/variables/(.+)'))[1]\n  };\n};\n\nexports.idsToVarName = function(projectId, configId, varId) {\n  return  _.join(['projects', projectId, 'configs', configId, 'variables', varId], '/');\n};\n\nexports.getFirebaseConfig = function(projectId, instance) {\n  return RSVP.all([storage.buckets.getDefault(projectId), apikeys.getServerKey(projectId)])\n  .then(function(results) {\n    return {\n      databaseURL: utils.addSubdomain(api.realtimeOrigin, instance),\n      storageBucket: results[0],\n      apiKey: results[1],\n      authDomain: instance + '.firebaseapp.com'\n    };\n  });\n};\n\n\nexports.setVariablesRecursive = function(projectId, configId, varPath, val) {\n  try {\n    var parsed = JSON.parse(val);\n    if (!_.isPlainObject(parsed)) { // could be a number, etc.\n      return _setVariable(projectId, configId, varPath, val);\n    } else if (parsed === null) {\n      return _setVariable(projectId, configId, varPath, 'null');\n    }\n    return RSVP.all(_.map(parsed, function(item, key) {\n      var newVarPath = varPath ? _.join([varPath, key], '/') : key;\n      if (_.isPlainObject(parsed)) {\n        item = JSON.stringify(item);\n      }\n      return exports.setVariablesRecursive(projectId, configId, newVarPath, item);\n    }));\n  } catch (e) {\n    return _setVariable(projectId, configId, varPath, val);\n  }\n};\n\nexports.materializeConfig = function(configName, output) {\n  var _materializeVariable = function(varName) {\n    return runtimeconfig.variables.get(varName).then(function(variable) {\n      var id = exports.varNameToIds(variable.name);\n      var key = id.config + '.' + id.variable.split('/').join('.');\n      _.set(output, key, variable.text);\n    });\n  };\n\n  var _traverseVariables = function(variables) {\n    return RSVP.all(_.map(variables, function(variable) {\n      return _materializeVariable(variable.name);\n    }));\n  };\n\n  return runtimeconfig.variables.list(configName).then(function(variables) {\n    return _traverseVariables(variables);\n  }).then(function() {\n    return output;\n  });\n};\n\nexports.materializeAll = function(projectId) {\n  var output = {};\n  return runtimeconfig.configs.list(projectId).then(function(configs) {\n    return RSVP.all(_.map(configs, function(config) {\n      if (config.name.match(new RegExp('configs/firebase'))) { // ignore firebase config\n        return RSVP.resolve();\n      }\n      return exports.materializeConfig(config.name, output);\n    })).then(function() {\n      return output;\n    });\n  });\n};\n\nexports.parseSetArgs = function(args) {\n  var parsed = [];\n  _.forEach(args, function(arg) {\n    var parts = arg.split('=');\n    var key = parts[0];\n    if (parts.length < 2) {\n      throw new FirebaseError('Invalid argument ' + chalk.bold(arg) + ', must be in key=val format');\n    }\n    if (/[A-Z]/.test(key)) {\n      throw new FirebaseError('Invalid config name ' + chalk.bold(key) + ', cannot use upper case.');\n    }\n\n    var id = _keyToIds(key);\n    if (_.includes(exports.RESERVED_NAMESPACES, id.config.toLowerCase())) {\n      throw new FirebaseError('Cannot set to reserved namespace ' + chalk.bold(id.config));\n    }\n\n    var val = parts.slice(1).join('='); // So that someone can have '=' within a variable value\n    parsed.push({\n      configId: id.config,\n      varId: id.variable,\n      val: val\n    });\n  });\n  return parsed;\n};\n\nexports.parseUnsetArgs = function(args) {\n  var parsed = [];\n  args = args[0].split(',');\n  _.forEach(args, function(key) {\n    var id = _keyToIds(key);\n    if (_.includes(exports.RESERVED_NAMESPACES, id.config.toLowerCase())) {\n      throw new FirebaseError('Cannot unset reserved namespace ' + chalk.bold(id.config));\n    }\n\n    parsed.push({\n      configId: id.config,\n      varId: id.variable\n    });\n  });\n  return parsed;\n};\n\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/gcp/runtimeconfig.js":"'use strict';\n\nvar api = require('../api');\nvar RSVP = require('rsvp');\nvar utils = require('../utils');\nvar logger = require('../logger');\nvar _ = require('lodash');\n\nvar API_VERSION = 'v1beta1';\n\nfunction _listConfigs(projectId) {\n  return api.request('GET', utils.endpoint([API_VERSION, 'projects', projectId, 'configs']), {\n    auth: true,\n    origin: api.runtimeconfigOrigin\n  }).then(function(resp) {\n    return RSVP.resolve(resp.body.configs);\n  });\n}\n\nfunction _createConfig(projectId, configId) {\n  var path = _.join(['projects', projectId, 'configs'], '/');\n  var endpoint = utils.endpoint([API_VERSION, path]);\n  return api.request('POST', endpoint, {\n    auth: true,\n    origin: api.runtimeconfigOrigin,\n    data: {\n      name: path + '/' + configId\n    }\n  }).catch(function(err) {\n    if (_.get(err, 'context.response.statusCode') === 409) {\n    // Config has already been created as part of a parallel operation during firebase functions:config:set\n      return RSVP.resolve();\n    }\n    return RSVP.reject();\n  });\n}\n\nfunction _deleteConfig(projectId, configId) {\n  return api.request('DELETE', utils.endpoint([API_VERSION, 'projects', projectId, 'configs', configId]), {\n    auth: true,\n    origin: api.runtimeconfigOrigin\n  });\n}\n\nfunction _listVariables(configPath) {\n  return api.request('GET', utils.endpoint([API_VERSION, configPath, 'variables']), {\n    auth: true,\n    origin: api.runtimeconfigOrigin\n  }).then(function(resp) {\n    return RSVP.resolve(resp.body.variables);\n  });\n}\n\nfunction _getVariable(varPath) {\n  return api.request('GET', utils.endpoint([API_VERSION, varPath]), {\n    auth: true,\n    origin: api.runtimeconfigOrigin\n  }).then(function(resp) {\n    return RSVP.resolve(resp.body);\n  });\n}\n\nfunction _createVariable(projectId, configId, varId, value) {\n  var path = _.join(['projects', projectId, 'configs', configId, 'variables'], '/');\n  var endpoint = utils.endpoint([API_VERSION, path]);\n  return api.request('POST', endpoint, {\n    auth: true,\n    origin: api.runtimeconfigOrigin,\n    data: {\n      name: path + '/' + varId,\n      text: value\n    }\n  }).catch(function(err) {\n    if (_.get(err, 'context.response.statusCode') === 404) { // parent config doesn't exist yet\n      return _createConfig(projectId, configId).then(function() {\n        return _createVariable(projectId, configId, varId, value);\n      });\n    }\n    return RSVP.reject(err);\n  });\n}\n\nfunction _updateVariable(projectId, configId, varId, value) {\n  var path = _.join(['projects', projectId, 'configs', configId, 'variables', varId], '/');\n  var endpoint = utils.endpoint([API_VERSION, path]);\n  return api.request('PUT', endpoint, {\n    auth: true,\n    origin: api.runtimeconfigOrigin,\n    data: {\n      name: path,\n      text: value\n    }\n  });\n}\n\nfunction _setVariable(projectId, configId, varId, value) {\n  var path = _.join(['projects', projectId, 'configs', configId, 'variables', varId], '/');\n  return _getVariable(path).then(function() {\n    return _updateVariable(projectId, configId, varId, value);\n  }).catch(function(err) {\n    if (_.get(err, 'context.response.statusCode') === 404) {\n      return _createVariable(projectId, configId, varId, value);\n    }\n    return RSVP.reject(err);\n  });\n}\n\nfunction _deleteVariable(projectId, configId, varId) {\n  var endpoint = utils.endpoint([API_VERSION, 'projects', projectId, 'configs', configId, 'variables', varId])\n    + '?recursive=true';\n  return api.request('DELETE', endpoint, {\n    auth: true,\n    origin: api.runtimeconfigOrigin\n  }).catch(function(err) {\n    if (_.get(err, 'context.response.statusCode') === 404) {\n      logger.debug('Variable already deleted.');\n      return RSVP.resolve();\n    }\n    return RSVP.reject(err);\n  });\n}\n\n\nmodule.exports = {\n  configs: {\n    list: _listConfigs,\n    create: _createConfig,\n    delete: _deleteConfig\n  },\n  variables: {\n    list: _listVariables,\n    get: _getVariable,\n    set: _setVariable,\n    delete: _deleteVariable\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/gcp/storage.js":"'use strict';\n\nvar RSVP = require('rsvp');\nvar api = require('../api');\nvar logger = require('../logger');\nvar FirebaseError = require('../error');\n\nvar version = 'v1';\n\nfunction _getDefaultBucket(projectId) {\n  return api.request('GET', '/v1/apps/' + projectId, {\n    auth: true,\n    origin: api.appengineOrigin\n  }).then(function(resp) {\n    if (resp.body.defaultBucket === 'undefined') {\n      logger.debug('Default storage bucket is undefined.');\n      return RSVP.reject(new FirebaseError('Your project is being set up. Please wait a minute before deploying again.'));\n    }\n    return RSVP.resolve(resp.body.defaultBucket);\n  }, function(err) {\n    logger.info('\\n\\nThere was an issue deploying your functions. Verify that your project has a Google App Engine instance setup at https://console.cloud.google.com/appengine and try again. If this issue persists, please contact support.');\n    return RSVP.reject(err);\n  });\n}\n\n// helper functions for creating staging buckets, delete later-----------\nfunction _getOperation(operation) {\n  return api.request('GET', '/v1/' + operation, {\n    auth: true,\n    origin: api.appengineOrigin\n  });\n}\n\nfunction _pollOperation(operation) {\n  var POLL_INTERVAL = 500; // 0.5 second\n  return new RSVP.Promise(function(resolve) {\n    setTimeout(function() { resolve(); }, POLL_INTERVAL);\n  }).then(function() {\n    return _getOperation(operation).then(function(res) {\n      if (res.body.done) {\n        return true;\n      }\n      return _pollOperation(operation);\n    });\n  });\n}\n// end of helper functions for creating staging buckets-------------------\n\nfunction _getBucket(bucket) {\n  return api.request('GET', '/storage/' + version + '/b/' + bucket, {\n    auth: true,\n    origin: api.googleOrigin\n  });\n}\n\nfunction _createBucket(projectId) {\n  // var bucket = _functionsBucketName(projectId);\n  // return api.request('POST', '/storage/' + version + '/b?project=' + projectId, {\n  //   auth: true,\n  //   data: {\n  //     name: bucket\n  //   },\n  //   origin: api.googleOrigin\n  return api.request('POST', '/v1/apps/' + projectId + ':repair', {\n    auth: true,\n    origin: api.appengineOrigin\n  }).then(function(resp) {\n    return _pollOperation(resp.body.name);\n  }).catch(function(err) {\n    logger.info('\\n\\nThere was an issue deploying your functions. Verify that your project has a Google App Engine instance setup at https://console.cloud.google.com/appengine and try again. If this issue persists, please contact support.');\n    return RSVP.reject(err);\n  });\n}\n\nfunction _getOrCreateBucket(projectId, bucketName) {\n  return _getBucket(bucketName).catch(function(err) {\n    if (err.context.response.statusCode === 404) {\n      logger.debug('creating bucket ' + bucketName + '...');\n      return _createBucket(projectId);\n    }\n    return RSVP.reject(err);\n  }).then(function() {\n    return RSVP.resolve(bucketName);\n  });\n}\n\nfunction _uploadSource(source, bucket) {\n  var resource = ['b', bucket, 'o'].join('/');\n  var endpoint = '/upload/storage/' + version + '/' + resource + '?uploadType=media&name=' + module.exports.archiveName;\n  return api.request('POST', endpoint, {\n    auth: true,\n    headers: {\n      'Content-Type': 'application/zip',\n      'Content-Length': source.size\n    },\n    data: source,\n    json: false,\n    origin: api.googleOrigin\n  });\n}\n\nmodule.exports = {\n  archiveName: 'firebase-functions-source',\n  buckets: {\n    get: _getBucket,\n    acquire: _getOrCreateBucket,\n    getDefault: _getDefaultBucket\n  },\n  upload: _uploadSource\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/gcp/apikeys.js":"'use strict';\n\nvar api = require('../api');\nvar _ = require('lodash');\nvar RSVP = require('rsvp');\nvar logger = require('../logger');\n\nvar version = 'v1';\n\nfunction _getKeys(projectId) {\n  return api.request('GET', '/' + version + '/projects/' + projectId + '/apiKeys', {\n    auth: true,\n    origin: api.apikeysOrigin\n  }).then(function(res) {\n    return res.body.keys;\n  });\n}\n\nfunction _getServerKey(projectId) {\n  return _getKeys(projectId).then(function(keys) {\n    var filter = function(elem) {\n      return /[Ss]erver/.test(elem.displayName);\n    };\n    return _.chain(keys).find(filter).get('currentKey').value();\n  }).catch(function(err) {\n    logger.debug('Error fetching server API key: ', err);\n    return RSVP.resolve(null);\n  });\n}\n\nmodule.exports = {\n  getServerKey: _getServerKey\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/deploy/functions/deploy.js":"'use strict';\n\nvar chalk = require('chalk');\nvar RSVP = require('rsvp');\nvar tmp = require('tmp');\nvar utils = require('../../utils');\nvar gcp = require('../../gcp');\nvar prepareFunctionsUpload = require('../../prepareFunctionsUpload');\n\ntmp.setGracefulCleanup();\n\nmodule.exports = function(context, options, payload) {\n  var _uploadSource = function(source) {\n    return gcp.storage.buckets.acquire(context.projectId, context.functionsBucket)\n    .then(function(bucketName) {\n      return gcp.storage.upload(source.stream, bucketName);\n    });\n  };\n  if (options.config.get('functions')) {\n    utils.logBullet(chalk.cyan.bold('functions:') + ' preparing ' + chalk.bold(options.config.get('functions.source')) + ' directory for uploading...');\n\n    return prepareFunctionsUpload(context, options).then(function(result) {\n      payload.functions = {\n        triggers: options.config.get('functions.triggers')\n      };\n\n      if (!result) {\n        return undefined;\n      }\n      return _uploadSource(result).then(function() {\n        utils.logSuccess(chalk.green.bold('functions:') + ' ' + chalk.bold(options.config.get('functions.source')) + ' folder uploaded successfully');\n      }).catch(function(err) {\n        utils.logWarning(chalk.yellow('functions:') + ' Upload Error: ' + err.message);\n      });\n    });\n  }\n  return RSVP.resolve();\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/gcp/index.js":"'use strict';\n\nmodule.exports = {\n  cloudlogging: require('./cloudlogging'),\n  cloudfunctions: require('./cloudfunctions'),\n  storage: require('./storage'),\n  apikeys: require('./apikeys')\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/gcp/cloudlogging.js":"'use strict';\n\nvar RSVP = require('rsvp');\nvar api = require('../api');\n\nvar version = 'v2beta1';\n\nvar _listEntries = function(projectId, filter, pageSize, order) {\n  return api.request('POST', '/' + version + '/entries:list', {\n    auth: true,\n    data: {\n      projectIds: [projectId],\n      filter: filter,\n      orderBy: 'timestamp ' + order,\n      pageSize: pageSize\n    },\n    origin: api.cloudloggingOrigin\n  }).then(function(result) {\n    return RSVP.resolve(result.body.entries);\n  });\n};\n\nmodule.exports = {\n  listEntries: _listEntries\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/gcp/cloudfunctions.js":"'use strict';\n\nvar api = require('../api');\nvar RSVP = require('rsvp');\nvar utils = require('../utils');\nvar _ = require('lodash');\nvar logger = require('../logger');\nvar chalk = require('chalk');\n\nvar version = 'v1beta2';\n\nfunction _functionsOpLogReject(func, type, err) {\n  utils.logWarning(chalk.bold.yellow('functions:') + ' failed to ' + type + ' function ' + func);\n  utils.logWarning(chalk.bold.yellow('functions: ') + err.message);\n  return RSVP.reject(err.message);\n}\n\nfunction _createFunction(options) {\n  var location = 'projects/' + options.projectId + '/locations/' + options.region;\n  var func = location + '/functions/' + options.functionName;\n  var endpoint = '/' + version + '/' + location + '/functions';\n  var data = {\n    sourceArchiveUrl: options.sourceArchiveUrl,\n    name: func,\n    entryPoint: options.entryPoint\n  };\n  if (options.availableMemory) {\n    data.availableMemoryMb = options.availableMemory;\n  }\n  if (options.functionTimeout) {\n    data.timeout = options.functionTimeout;\n  }\n  return api.request('POST', endpoint, {\n    auth: true,\n    data: _.assign(data, options.trigger),\n    origin: api.functionsOrigin\n  }).then(function(resp) {\n    return RSVP.resolve({func: func, eventType: options.eventType, done: false, name: resp.body.name, type: 'create'});\n  }, function(err) {\n    return _functionsOpLogReject(options.functionName, 'create', err);\n  });\n}\n\nfunction _updateFunction(options) {\n  var location = 'projects/' + options.projectId + '/locations/' + options.region;\n  var func = location + '/functions/' + options.functionName;\n  var endpoint = '/' + version + '/' + func;\n  var data = _.assign({\n    sourceArchiveUrl: options.sourceArchiveUrl,\n    name: func,\n    entryPoint: options.entryPoint,\n    timeout: options.functionTimeout,\n    availableMemoryMb: options.availableMemory\n  }, options.trigger);\n  return api.request('PUT', endpoint, {\n    auth: true,\n    data: data,\n    origin: api.functionsOrigin\n  }).then(function(resp) {\n    return RSVP.resolve({func: func, done: false, name: resp.body.name, type: 'update'});\n  }, function(err) {\n    return _functionsOpLogReject(options.functionName, 'update', err);\n  });\n}\n\nfunction _deleteFunction(projectId, region, functionName) {\n  var location = 'projects/' + projectId + '/locations/' + region;\n  var func = location + '/functions/' + functionName;\n  var endpoint = '/' + version + '/' + func;\n  return api.request('DELETE', endpoint, {\n    auth: true,\n    origin: api.functionsOrigin\n  }).then(function(resp) {\n    return RSVP.resolve({func: func, done: false, name: resp.body.name, type: 'delete'});\n  }, function(err) {\n    return _functionsOpLogReject(functionName, 'delete', err);\n  });\n}\n\nfunction _listFunctions(projectId, region) {\n  var endpoint = '/' + version + '/projects/' + projectId + '/locations/' + region + '/functions';\n  return api.request('GET', endpoint, {\n    auth: true,\n    origin: api.functionsOrigin\n  }).then(function(resp) {\n    var functionsList = resp.body.functions || [];\n    _.forEach(functionsList, function(f) {\n      f.functionName = f.name.substring(f.name.lastIndexOf('/') + 1);\n    });\n    return RSVP.resolve(functionsList);\n  }, function(err) {\n    logger.debug('[functions] failed to list functions for ' + projectId);\n    logger.debug('[functions] ' + err.message);\n    return RSVP.reject(err.message);\n  });\n}\n\nfunction _checkOperation(operation) {\n  return api.request('GET', '/' + version + '/' + operation.name, {\n    auth: true,\n    origin: api.functionsOrigin\n  }).then(function(resp) {\n    if (resp.body.done) {\n      operation.done = true;\n    }\n    if (_.has(resp.body, 'error')) {\n      operation.error = resp.body.error;\n    }\n    return RSVP.resolve(operation);\n  }, function(err) {\n    logger.debug('[functions] failed to get status of operation: ' + operation.name);\n    logger.debug('[functions] ' + err.message);\n    operation.error = err;\n    return RSVP.reject(err.message);\n  });\n}\n\nmodule.exports = {\n  create: _createFunction,\n  update: _updateFunction,\n  delete: _deleteFunction,\n  list: _listFunctions,\n  check: _checkOperation\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/prepareFunctionsUpload.js":"'use strict';\n\nvar _ = require('lodash');\nvar archiver = require('archiver');\nvar chalk = require('chalk');\nvar filesize = require('filesize');\nvar fs = require('fs-extra');\nvar fork = require('child_process').fork;\nvar path = require('path');\nvar RSVP = require('rsvp');\nvar tmp = require('tmp');\n\nvar FirebaseError = require('./error');\nvar functionsConfig = require('./functionsConfig');\nvar getProjectId = require('./getProjectId');\nvar logger = require('./logger');\nvar track = require('./track');\nvar utils = require('./utils');\nvar fstreamIgnore = require('fstream-ignore');\n\nvar CONFIG_DEST_FILE = '.runtimeconfig.json';\n\nvar _prepareSource = function(context, options) {\n  var tmpdir = tmp.dirSync({prefix: 'fbfn_'});\n  var configDest = path.join(tmpdir.name, CONFIG_DEST_FILE);\n  try {\n    fs.copySync(options.config.path(options.config.get('functions.source')), tmpdir.name);\n  } catch (err) {\n    throw new FirebaseError('Problem preparing functions directory for upload.', {exit: 1});\n  }\n  return functionsConfig.materializeAll(getProjectId(options)).then(function(output) {\n    var firebaseConfig = _.get(context, 'firebaseConfig');\n    _.set(output, 'firebase', firebaseConfig);\n    fs.ensureFileSync(configDest);\n    fs.writeFileSync(configDest, JSON.stringify(output, null, 2));\n    logger.debug('> [functions] runtime config materialized as:', JSON.stringify(output, null, 2));\n    return tmpdir;\n  });\n};\n\nvar TRIGGER_PARSER = path.resolve(__dirname, './triggerParser.js');\nvar _parseTriggers = function(options, tmpdir) {\n  return new RSVP.Promise(function(resolve, reject) {\n    var env = {\n      GCLOUD_PROJECT: getProjectId(options),\n      DB_NAMESPACE: options.instance\n    };\n    var parser = fork(TRIGGER_PARSER, [tmpdir.name], {silent: true, env: env});\n\n    parser.on('message', function(message) {\n      if (message.triggers) {\n        logger.debug('> [functions] parsed triggers:', JSON.stringify(message.triggers, null, 2));\n        track('Functions Deploy (Count)', '', message.triggers.length);\n        resolve(message.triggers);\n      } else if (message.error) {\n        reject(new FirebaseError(message.error, {exit: 1}));\n      }\n    });\n\n    parser.on('exit', function(code) {\n      if (code !== 0) {\n        reject(new FirebaseError('There was an unknown problem while trying to parse function triggers.', {exit: 2}));\n      }\n    });\n  });\n};\n\nvar _packageSource = function(options, tmpdir) {\n  var sourceDir = tmpdir.name;\n  return new RSVP.Promise(function(resolve, reject) {\n    var tmpFile = tmp.fileSync({prefix: 'firebase-functions-', postfix: '.zip'});\n\n    var fileStream = fs.createWriteStream(tmpFile.name, {\n      flags: 'w',\n      defaultEncoding: 'binary'\n    });\n\n    var archive = archiver('zip');\n    fileStream.on('finish', function() {\n      utils.logBullet(chalk.cyan.bold('functions:') + ' packaged ' + chalk.bold(options.config.get('functions.source')) + ' (' + filesize(archive.pointer()) + ') for uploading');\n      resolve({\n        file: tmpFile.name,\n        stream: fs.createReadStream(tmpFile.name),\n        size: archive.pointer()\n      });\n    });\n\n    archive.on('error', function(err) {\n      reject(new FirebaseError('Could not read source directory. Remove links and shortcuts and try again.', {\n        original: err,\n        exit: 1\n      }));\n    });\n    archive.pipe(fileStream);\n    var reader = fstreamIgnore({\n      path: sourceDir,\n      type: 'Directory',\n      follow: true\n    });\n\n    // we must ignore this or weird things happen if\n    // you're in the public dir when you deploy\n    reader.addIgnoreRules(['firebase-debug.log']);\n    reader.addIgnoreRules(options.config.get(['functions', '.ignore'], ['**/.*', '**/node_modules/**']));\n    // We want to always upload the env file regardless of ignore rules\n    reader.addIgnoreRules(['!' + CONFIG_DEST_FILE]);\n\n    reader.on('child', function(file) {\n      if (file.type !== 'Directory') {\n        archive.append(file, { name: path.relative(sourceDir, file.path), mode: file.props.mode });\n      }\n    });\n\n    reader.on('error', function(err) {\n      reject(new FirebaseError('Could not read source directory. Remove links and shortcuts and try again.', {\n        original: err,\n        exit: 1\n      }));\n    });\n\n    reader.on('end', function() {\n      archive.finalize();\n      fs.removeSync(tmpdir.name);\n    });\n  });\n};\n\nmodule.exports = function(context, options) {\n  var tmpdir;\n  return _prepareSource(context, options).then(function(result) {\n    tmpdir = result;\n    return _parseTriggers(options, tmpdir);\n  }).then(function(triggers) {\n    options.config.set('functions.triggers', triggers);\n    if (options.config.get('functions.triggers').length === 0) {\n      return RSVP.resolve(null);\n    }\n    return _packageSource(options, tmpdir);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/deploy/functions/release.js":"'use strict';\n\nvar chalk = require('chalk');\nvar _ = require('lodash');\nvar RSVP = require('rsvp');\n\nvar FirebaseError = require('../../error');\nvar gcp = require('../../gcp');\nvar logger = require('../../logger');\nvar track = require('../../track');\nvar utils = require('../../utils');\n\nmodule.exports = function(context, options, payload) {\n  if (!options.config.has('functions')) {\n    return RSVP.resolve();\n  }\n\n  var POLL_INTERVAL = 5000; // 5 sec\n  var GCP_REGION = 'us-central1';\n  var projectId = context.projectId;\n  var sourceUrl = 'gs://' + context.functionsBucket + '/' + gcp.storage.archiveName;\n  var legacySourceUrl = 'gs://' + projectId + '-gcf/' + projectId;\n\n  var functionsInfo = payload.functions.triggers;\n  var timings = {};\n\n  function _startTimer(name, type) {\n    timings[name] = {type: type, t0: process.hrtime()};\n  }\n\n  function _endTimer(name) {\n    if (!timings[name]) {\n      logger.debug('[functions] no timer initialized for', name, timings[name].type);\n      return;\n    }\n\n    // hrtime returns a duration as an array of [seconds, nanos]\n    var duration = process.hrtime(timings[name].t0);\n    track('Functions Deploy (Duration)', timings[name].type, duration[0] * 1000 + Math.round(duration[1] * 1e-6));\n  }\n\n  function _fetchTriggerUrls(ops) {\n    return gcp.cloudfunctions.list(projectId, GCP_REGION).then(function(functions) {\n      var httpFunctions = _.chain(functions).filter({ sourceArchiveUrl: sourceUrl}).filter('httpsTrigger').value();\n      _.forEach(httpFunctions, function(httpFunc) {\n        _.chain(ops).find({ func: httpFunc.name }).assign({ triggerUrl: httpFunc.httpsTrigger.url}).value();\n      });\n      return RSVP.resolve();\n    });\n  }\n\n  function _reportResults(successfulCalls, failedCalls) {\n    function logFailedOps(ops) {\n      _.forEach(ops, function(operation) {\n        var parts = operation.func.split('/');\n        var functionName = parts[5];\n        utils.logWarning(chalk.bold.yellow('functions[' + functionName + ']: ') + 'Deploy Error: ' + operation.error.message);\n      });\n    }\n\n    function logSuccessfulOps(ops) {\n      var functionUrls = [];\n      _.forEach(ops, function(operation) {\n        var parts = operation.func.split('/');\n        var functionName = parts[5];\n        if (operation.triggerUrl && operation.type !== 'delete') {\n          var entry = { 'funcName': functionName, 'url': operation.triggerUrl};\n          functionUrls = _.concat(functionUrls, entry);\n        }\n        utils.logSuccess(chalk.bold.green('functions[' + functionName + ']: ') + 'Successful ' + operation.type + ' operation. ');\n        if (operation.type === 'create' && operation.eventType.startsWith('providers/google.firebase.analytics/')) {\n          utils.logWarning(chalk.bold.yellow('functions[' + functionName + ']: during beta, new Analytics functions may take a few hours to start receiving events.'));\n        }\n      });\n\n      if (functionUrls.length > 0) {\n        _.set(context, 'functionUrls', functionUrls);\n      }\n    }\n\n    var failedChecks = _.filter(successfulCalls, function(op) {\n      return !op.done && op.error;\n    });\n    var failedOps = _.filter(successfulCalls, function(op) {\n      return op.done && op.error;\n    });\n    var successfulOps = _.filter(successfulCalls, function(op) {\n      return op.done && !op.error;\n    });\n\n    var failed = false;\n\n    var failCount = failedOps.length + failedCalls.length;\n    track('Functions Deploy (Result)', 'failure', failCount.length || 0);\n    track('Functions Deploy (Result)', 'success', successfulOps.length || 0);\n\n    if (failedCalls.length > 0) {\n      failed = true;\n      utils.logWarning(chalk.bold.yellow('functions: ') + failedCalls.length + ' function(s) failed to be deployed.');\n      logger.debug(failedCalls);\n    }\n    if (failedOps.length > 0) {\n      failed = true;\n      logFailedOps(failedOps);\n    }\n    if (failedChecks.length > 0) {\n      utils.logWarning(chalk.bold.yellow('functions: ') + 'failed to get status of ' + failedChecks.length + ' operation(s).');\n      utils.logWarning(chalk.bold.yellow('functions: ') + 'run ' + chalk.bold('firebase functions:log') + ' in a few minutes to ensure that your functions deployed properly.');\n    }\n    if (successfulOps.length > 0) {\n      logSuccessfulOps(successfulOps);\n      if (!failed) {\n        utils.logSuccess(chalk.bold.green('functions: ') + 'all functions deployed successfully!');\n      } else {\n        utils.logSuccess(chalk.bold.green('functions: ') + successfulOps.length + ' function(s) deployed successfully.');\n      }\n    }\n    return failed ? RSVP.reject() : RSVP.resolve();\n  }\n\n  function _nameFromOperation(operation) {\n    if (!operation || !_.isString(operation.func)) {\n      return null;\n    }\n\n    return operation.func.split('/')[5];\n  }\n\n  function _pollOperations(successfulCalls) {\n    function logOps(ops) {\n      _.forEach(ops, function(operation) {\n        var functionName = _nameFromOperation(operation);\n        var msg = '[functions] operation poll: '\n          + functionName + ': '\n          + operation.type + ' ' + operation.name + ' is '\n          + (operation.done ? 'done.' : 'not done.');\n        logger.debug(msg);\n      });\n    }\n    return new RSVP.Promise(function(resolve, reject) {\n      function poll() {\n        var unfinishedOps = _.chain(successfulCalls).filter(function(operation) {\n          return !(operation.done || operation.error);\n        }).map(function(operation) {\n          return gcp.cloudfunctions.check(operation).then(function(op) {\n            var name = _nameFromOperation(op);\n            if (name && op.done) {\n              _endTimer(name);\n            }\n            return op;\n          });\n        }).value();\n\n        if (unfinishedOps.length === 0) {\n          return resolve();\n        }\n\n        RSVP.allSettled(unfinishedOps).then(function(checks) {\n          var successfulChecks = _.chain(checks).filter({'state': 'fulfilled'}).map('value').value();\n          logOps(successfulChecks);\n\n          var allDone = _.every(successfulChecks, { done: true });\n          if (allDone) {\n            return resolve();\n          }\n          setTimeout(poll, POLL_INTERVAL);\n        }).catch(function(err) {\n          return reject(err);\n        });\n      }\n      poll();\n    });\n  }\n\n  function _prepFunctionOp(functionInfo) {\n    if (functionInfo.httpsTrigger) {\n      return RSVP.resolve(_.pick(functionInfo, 'httpsTrigger'));\n    } else if (functionInfo.eventTrigger) {\n      var trigger = functionInfo.eventTrigger;\n      if (trigger.eventType === 'providers/cloud.storage/eventTypes/object.change' && !trigger.resource) {\n        var bucket = _.get(context, 'firebaseConfig.storageBucket');\n        _.set(trigger, 'resource', 'projects/_/buckets/' + bucket);\n      }\n      return RSVP.resolve({eventTrigger: trigger});\n    }\n    logger.debug('Unknown trigger type found in:', functionInfo);\n    return RSVP.reject(new Error('Could not parse function trigger, unknown trigger type.'));\n  }\n\n  delete payload.functions;\n  var uploadedNames = _.map(functionsInfo, 'name');\n\n  return gcp.cloudfunctions.list(projectId, GCP_REGION).then(function(existingFunctions) {\n    var pluckName = function(functionObject) {\n      var fullName = _.get(functionObject, 'name'); // e.g.'projects/proj1/locations/us-central1/functions/func'\n      return _.last(fullName.split('/'));\n    };\n\n    var existingNames = _.map(existingFunctions, pluckName);\n\n    var addOps = _.chain(uploadedNames)\n      .difference(existingNames)\n      .map(function(functionName) {\n        var functionInfo = _.find(functionsInfo, {'name': functionName});\n        return _prepFunctionOp(functionInfo).then(function(functionTrigger) {\n          utils.logBullet(chalk.bold.cyan('functions: ') + 'creating function ' + chalk.bold(functionName) + '...');\n          logger.debug('Trigger is: ', functionTrigger);\n          var eventType = functionTrigger.eventTrigger ? functionTrigger.eventTrigger.eventType : 'https';\n          _startTimer(functionName, 'create');\n          return gcp.cloudfunctions.create({\n            projectId: projectId,\n            region: GCP_REGION,\n            eventType: eventType,\n            functionName: functionName,\n            entryPoint: functionInfo.entryPoint,\n            trigger: functionTrigger,\n            sourceArchiveUrl: sourceUrl\n          });\n        });\n      }).value();\n\n    var updateOps = _.chain(uploadedNames)\n      .intersection(existingNames)\n      .map(function(functionName) {\n        var functionInfo = _.find(functionsInfo, {'name': functionName});\n        return _prepFunctionOp(functionInfo, functionName).then(function(functionTrigger) {\n          utils.logBullet(chalk.bold.cyan('functions: ') + 'updating function ' + chalk.bold(functionName) + '...');\n          logger.debug('Trigger is: ', functionTrigger);\n          var existingFunction = _.find(existingFunctions, function(func) {\n            return func.name.match(new RegExp('/' + functionName + '$'));\n          });\n          var existingTriggerType = _.get(existingFunction, 'eventTrigger.eventType');\n          var newTriggerType = _.get(functionTrigger, 'eventTrigger.eventType');\n          var isNowDBTrigger = newTriggerType === 'providers/google.firebase.database/eventTypes/ref.write';\n          // Firebase Database triggers could be outdated in 2 ways: they are still a PubSub trigger, or their event\n          // type contains 'data.write' instead of 'ref.write'. GCF won't allow us to change the trigger type of an existing trigger\n          // so we have to delete functions that were based on the old prototype and create them as real database triggers.\n          if (isNowDBTrigger && newTriggerType !== existingTriggerType) {\n            var eventType = functionTrigger.eventTrigger ? functionTrigger.eventTrigger.eventType : 'https';\n            return gcp.cloudfunctions.delete(projectId, GCP_REGION, functionName)\n              .then(function(call) {\n                return _pollOperations([call]);\n              }).then(function() {\n                return gcp.cloudfunctions.create({\n                  projectId: projectId,\n                  region: GCP_REGION,\n                  eventType: eventType,\n                  functionName: functionName,\n                  entryPoint: functionInfo.entryPoint,\n                  trigger: functionTrigger,\n                  sourceArchiveUrl: sourceUrl,\n                  availableMemory: existingFunction.availableMemoryMb,\n                  functionTimeout: existingFunction.timeout\n                });\n              });\n          }\n          _startTimer(functionName, 'update');\n          // Also provide `availableMemory` and `timeout` retrieved from `gcp.cloudfunctions.list`\n          // This is a stop gap until GCF bug is fixed (https://buganizer.corp.google.com/issues/36844999)\n          return gcp.cloudfunctions.update({\n            projectId: projectId,\n            region: GCP_REGION,\n            functionName: functionName,\n            entryPoint: functionInfo.entryPoint,\n            trigger: functionTrigger,\n            sourceArchiveUrl: sourceUrl,\n            availableMemory: existingFunction.availableMemoryMb,\n            functionTimeout: existingFunction.timeout\n          });\n        });\n      }).value();\n\n\n    var deleteOps = _.chain(existingFunctions)\n      .filter(function(o) {\n        return o.sourceArchiveUrl === sourceUrl || o.sourceArchiveUrl === legacySourceUrl;\n      }) // only delete functions uploaded via firebase-tools\n      .map(pluckName)\n      .difference(uploadedNames)\n      .map(function(functionName) {\n        utils.logBullet(chalk.bold.cyan('functions: ') + 'deleting function ' + chalk.bold(functionName) + '...');\n        _startTimer(functionName, 'delete');\n        return gcp.cloudfunctions.delete(projectId, GCP_REGION, functionName);\n      }).value();\n    return RSVP.allSettled([].concat(addOps, updateOps, deleteOps));\n  }).then(function(allOps) {\n    var failedCalls = _.chain(allOps).filter({'state': 'rejected'}).map('reason').value();\n    var successfulCalls = _.chain(allOps).filter({'state': 'fulfilled'}).map('value').value();\n    var fetch =  _fetchTriggerUrls(successfulCalls);\n    var poll = _pollOperations(successfulCalls);\n\n    return RSVP.allSettled([fetch, poll]).then(function() {\n      return _reportResults(successfulCalls, failedCalls);\n    });\n  }).catch(function(e) {\n    logger.info('\\n\\nFunctions deploy had errors. To continue deploying other features (such as database), run:');\n    logger.info('    ' + chalk.bold('firebase deploy --except functions'));\n    if (e) {\n      logger.debug(e.stack);\n    }\n    return RSVP.reject(new FirebaseError('Functions did not deploy properly.'));\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/deploy/storage/index.js":"'use strict';\n\nmodule.exports = {\n  prepare: require('./prepare')\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/deploy/storage/prepare.js":"'use strict';\n\nvar fs = require('fs');\nvar RSVP = require('rsvp');\nvar api = require('../../api');\nvar utils = require('../../utils');\nvar chalk = require('chalk');\n\nmodule.exports = function(context, options, payload) {\n  var rulesPath = options.config.get('storage.rules');\n  if (rulesPath) {\n    rulesPath = options.config.path(rulesPath);\n    var src = fs.readFileSync(rulesPath, 'utf8');\n    utils.logBullet(chalk.bold.cyan('storage:') + ' checking rules for compilation errors...');\n    return api.request('POST', '/v1/projects/' + encodeURIComponent(options.project) + ':test', {\n      origin: api.rulesOrigin,\n      data: {\n        source: {\n          files: [{\n            content: src,\n            name: 'storage.rules'\n          }]\n        }\n      },\n      auth: true\n    }).then(function(response) {\n      if (response.body && response.body.issues && response.body.issues.length > 0) {\n        var add = response.body.issues.length === 1 ? '' : 's';\n        var message = 'Compilation error' + add + ' in ' + chalk.bold(options.config.get('storage.rules')) + ':\\n';\n        response.body.issues.forEach(function(issue) {\n          message += '\\n[' + issue.severity.substring(0, 1) + '] ' + issue.sourcePosition.line + ':' + issue.sourcePosition.column + ' - ' + issue.description;\n        });\n\n        return utils.reject(message, {exit: 1});\n      }\n\n      utils.logSuccess(chalk.bold.green('storage:') + ' rules file compiled successfully');\n      payload.storage = {rules: [\n        {name: options.config.get('storage.rules'), content: src}\n      ]};\n      return RSVP.resolve();\n    });\n  }\n\n  return RSVP.resolve();\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/requireConfig.js":"'use strict';\n\nvar RSVP = require('rsvp');\nvar FirebaseError = require('./error');\n\nmodule.exports = function(options) {\n  if (options.config) {\n    return RSVP.resolve();\n  }\n  return RSVP.reject(\n    options.configError ||\n    new FirebaseError('Not in a Firebase project directory (could not locate firebase.json)', {exit: 1})\n  );\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/hosting-disable.js":"'use strict';\n\nvar Command = require('../lib/command');\nvar requireAccess = require('../lib/requireAccess');\nvar api = require('../lib/api');\nvar utils = require('../lib/utils');\nvar prompt = require('../lib/prompt');\nvar chalk = require('chalk');\nvar RSVP = require('rsvp');\n\nmodule.exports = new Command('hosting:disable')\n  .description('stop serving web traffic to your Firebase Hosting site')\n  .option('-y, --confirm', 'skip confirmation')\n  .before(requireAccess)\n  .action(function(options) {\n    return prompt(options, [\n      {\n        type: 'confirm',\n        name: 'confirm',\n        message: 'Are you sure you want to disable Firebase Hosting?\\n  ' + chalk.bold.underline('This will immediately make your site inaccessible!')\n      }\n    ]).then(function() {\n      if (!options.confirm) {\n        return RSVP.resolve();\n      }\n\n      return api.request('POST', '/v1/projects/' + encodeURIComponent(options.project) + '/releases', {\n        auth: true,\n        data: {\n          hosting: {\n            disabled: true\n          }\n        },\n        origin: api.deployOrigin\n      });\n    }).then(function() {\n      if (options.confirm) {\n        utils.logSuccess('Hosting has been disabled for ' + chalk.bold(options.project) + '. Deploy a new version to re-enable.');\n      }\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/functions-log.js":"'use strict';\n\nvar _ = require('lodash');\nvar RSVP = require('rsvp');\nvar Command = require('../lib/command');\nvar FirebaseError = require('../lib/error');\nvar gcp = require('../lib/gcp');\nvar getProjectId = require('../lib/getProjectId');\nvar logger = require('../lib/logger');\nvar requireAccess = require('../lib/requireAccess');\nvar scopes = require('../lib/scopes');\nvar open = require('open');\n\nmodule.exports = new Command('functions:log')\n  .description('read logs from deployed functions')\n  .option('--only <function_names>', 'only show logs of specified, comma-seperated functions (e.g. \"funcA,funcB\")')\n  .option('-n, --lines <num_lines>', 'specify number of log lines to fetch')\n  .option('--open', 'open logs page in web browser')\n  .before(requireAccess, [scopes.OPENID, scopes.CLOUD_PLATFORM])\n  .action(function(options) {\n    var projectId = getProjectId(options);\n    var apiFilter = 'resource.type=\"cloud_function\" ';\n    var consoleFilter = 'metadata.serviceName:\"cloudfunctions.googleapis.com\"';\n    if (options.only) {\n      var funcNames = options.only.split(',');\n      var apiFuncFilters = _.map(funcNames, function(funcName) {\n        return 'resource.labels.function_name=\"' + funcName + '\" ';\n      });\n      var consoleFuncFilters = _.map(funcNames, function(funcName) {\n        return 'metadata.labels.\"cloudfunctions.googleapis.com/function_name\":\"' + funcName + '\" ';\n      });\n      apiFilter += apiFuncFilters.join('OR ');\n      consoleFilter = [consoleFilter, consoleFuncFilters.join('%20OR%20')].join('%0A');\n    }\n    if (options.open) {\n      var url = 'https://console.developers.google.com/logs/viewer?advancedFilter=' + consoleFilter + '&project=' + projectId;\n      open(url);\n      return RSVP.resolve();\n    }\n    return gcp.cloudlogging.listEntries(projectId, apiFilter, options.lines || 35, 'desc')\n    .then(function(entries) {\n      for (var i = _.size(entries); i-- > 0;) {\n        var entry = entries[i];\n        logger.info(\n          entry.timestamp,\n          entry.severity.substring(0, 1),\n          entry.resource.labels.function_name + ':',\n          entry.textPayload);\n      }\n      if (_.isEmpty(entries)) {\n        logger.info('No log entries found.');\n      }\n      return RSVP.resolve(entries);\n    }).catch(function(err) {\n      return RSVP.reject(new FirebaseError(\n        'Failed to list log entries ' + err.message, {exit: 1}));\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/functions-config-clone.js":"'use strict';\n\nvar chalk = require('chalk');\nvar Command = require('../lib/command');\nvar functionsConfig = require('../lib/functionsConfig');\nvar functionsConfigClone = require('../lib/functionsConfigClone');\nvar getProjectId = require('../lib/getProjectId');\nvar requireAccess = require('../lib/requireAccess');\nvar scopes = require('../lib/scopes');\nvar utils = require('../lib/utils');\nvar logger = require('../lib/logger');\n\nmodule.exports = new Command('functions:config:clone')\n  .description('clone environment config from another project')\n  .option('--from <projectId>', 'the project from which to clone configuration')\n  .option('--only <keys>', 'a comma-separated list of keys to clone')\n  .option('--except <keys>', 'a comma-separated list of keys to not clone')\n  .before(requireAccess, [scopes.CLOUD_PLATFORM])\n  .before(functionsConfig.ensureApi)\n  .action(function(options) {\n    var projectId = getProjectId(options);\n    if (!options.from) {\n      return utils.reject('Must specify a source project in ' + chalk.bold('--from <projectId>') + ' option.');\n    } else if (options.from === projectId) {\n      return utils.reject('From project and destination can\\'t be the same project.');\n    } else if (options.only && options.except) {\n      return utils.reject('Cannot use both --only and --except at the same time.');\n    }\n\n    var only;\n    var except;\n    if (options.only) {\n      only = options.only.split(',');\n    } else if (options.except) {\n      except = options.except.split(',');\n    }\n\n    return functionsConfigClone(options.from, projectId, only, except).then(function() {\n      utils.logSuccess('Cloned functions config from ' + chalk.bold(options.from) + ' into ' + chalk.bold(projectId));\n      logger.info('\\nPlease deploy your functions for the change to take effect by running '\n        + chalk.bold('firebase deploy --only functions') + '\\n');\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/functionsConfigClone.js":"'use strict';\n\nvar _ = require('lodash');\nvar RSVP = require('rsvp');\nvar chalk = require('chalk');\nvar FirebaseError = require('./error');\nvar functionsConfig = require('./functionsConfig');\nvar runtimeconfig = require('./gcp/runtimeconfig');\n\n// Tests whether short is a prefix of long\nvar _matchPrefix = function(short, long) {\n  if (short.length > long.length) {\n    return false;\n  }\n  return _.reduce(short, function(accum, x, i) {\n    return accum && x === long[i];\n  }, true);\n};\n\nvar _applyExcept = function(json, except) {\n  _.forEach(except, function(key) {\n    _.unset(json, key);\n  });\n};\n\nvar _cloneVariable = function(varName, toProject) {\n  return runtimeconfig.variables.get(varName).then(function(variable) {\n    var id = functionsConfig.varNameToIds(variable.name);\n    return runtimeconfig.variables.set(toProject, id.config, id.variable, variable.text);\n  });\n};\n\nvar _cloneConfig = function(configName, toProject) {\n  return runtimeconfig.variables.list(configName).then(function(variables) {\n    return RSVP.all(_.map(variables, function(variable) {\n      return _cloneVariable(variable.name, toProject);\n    }));\n  });\n};\n\nvar _cloneConfigOrVariable = function(key, fromProject, toProject) {\n  var parts = key.split('.');\n  if (_.includes(exports.RESERVED_NAMESPACES, parts[0])) {\n    throw new FirebaseError('Cannot clone reserved namespace ' + chalk.bold(parts[0]));\n  }\n  var configName = _.join(['projects', fromProject, 'configs', parts[0]], '/');\n  if (parts.length === 1) {\n    return _cloneConfig(configName, toProject);\n  }\n  return runtimeconfig.variables.list(configName).then(function(variables) {\n    var promises = [];\n    _.forEach(variables, function(variable) {\n      var varId = functionsConfig.varNameToIds(variable.name).variable;\n      var variablePrefixFilter = parts.slice(1);\n      if (_matchPrefix(variablePrefixFilter, varId.split('/'))) {\n        promises.push(_cloneVariable(variable.name, toProject));\n      }\n    });\n    return RSVP.all(promises);\n  });\n};\n\nmodule.exports = function(fromProject, toProject, only, except) {\n  except = except || [];\n\n  if (only) {\n    return RSVP.all(_.map(only, function(key) {\n      return _cloneConfigOrVariable(key, fromProject, toProject);\n    }));\n  }\n  return functionsConfig.materializeAll(fromProject).then(function(toClone) {\n    _.unset(toClone, 'firebase'); // Do not clone firebase config\n    _applyExcept(toClone, except);\n    return RSVP.all(_.map(toClone, function(val, configId) {\n      return functionsConfig.setVariablesRecursive(toProject, configId, '', JSON.stringify(val));\n    }));\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/functions-config-get.js":"'use strict';\n\nvar _ = require('lodash');\nvar Command = require('../lib/command');\nvar getProjectId = require('../lib/getProjectId');\nvar logger = require('../lib/logger');\nvar requireAccess = require('../lib/requireAccess');\nvar scopes = require('../lib/scopes');\nvar functionsConfig = require('../lib/functionsConfig');\n\nfunction _materialize(projectId, path) {\n  if (_.isUndefined(path)) {\n    return functionsConfig.materializeAll(projectId);\n  }\n  var parts = path.split('.');\n  var configId = parts[0];\n  var configName = _.join(['projects', projectId, 'configs', configId], '/');\n  return functionsConfig.materializeConfig(configName, {}).then(function(result) {\n    var query =  _.chain(parts).join('.').value();\n    return query ? _.get(result, query) : result;\n  });\n}\n\nmodule.exports = new Command('functions:config:get [path]')\n  .description('fetch environment config stored at the given path')\n  .before(requireAccess, [scopes.CLOUD_PLATFORM])\n  .before(functionsConfig.ensureApi)\n  .action(function(path, options) {\n    return _materialize(getProjectId(options), path).then(function(result) {\n      logger.info(JSON.stringify(result, null, 2));\n      return result;\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/functions-config-set.js":"'use strict';\n\nvar chalk = require('chalk');\nvar RSVP = require('rsvp');\nvar Command = require('../lib/command');\nvar getProjectId = require('../lib/getProjectId');\nvar requireAccess = require('../lib/requireAccess');\nvar scopes = require('../lib/scopes');\nvar logger = require('../lib/logger');\nvar utils = require('../lib/utils');\nvar functionsConfig = require('../lib/functionsConfig');\n\nmodule.exports = new Command('functions:config:set [values...]')\n  .description('set environment config with key=value syntax')\n  .before(requireAccess, [scopes.CLOUD_PLATFORM])\n  .before(functionsConfig.ensureApi)\n  .action(function(args, options) {\n    if (!args.length) {\n      return utils.reject('Must supply at least one key/value pair, e.g. ' + chalk.bold('app.name=\"My App\"'));\n    }\n    var projectId = getProjectId(options);\n    var parsed = functionsConfig.parseSetArgs(args);\n    var promises = [];\n\n    parsed.forEach(function(item) {\n      promises.push(functionsConfig.setVariablesRecursive(projectId, item.configId, item.varId, item.val));\n    });\n\n    return RSVP.all(promises).then(function() {\n      utils.logSuccess('Functions config updated.');\n      logger.info('\\nPlease deploy your functions for the change to take effect by running '\n        + chalk.bold('firebase deploy --only functions') + '\\n');\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/functions-config-unset.js":"'use strict';\n\nvar _ = require('lodash');\nvar RSVP = require('rsvp');\nvar chalk = require('chalk');\nvar Command = require('../lib/command');\nvar functionsConfig = require('../lib/functionsConfig');\nvar getProjectId = require('../lib/getProjectId');\nvar logger = require('../lib/logger');\nvar requireAccess = require('../lib/requireAccess');\nvar scopes = require('../lib/scopes');\nvar utils = require('../lib/utils');\nvar runtimeconfig = require('../lib/gcp/runtimeconfig');\n\nmodule.exports = new Command('functions:config:unset [keys...]')\n  .description('unset environment config at the specified path(s)')\n  .before(requireAccess, [scopes.CLOUD_PLATFORM])\n  .before(functionsConfig.ensureApi)\n  .action(function(args, options) {\n    if (!args.length) {\n      return utils.reject('Must supply at least one key, e.g. ' + chalk.bold('app.name'));\n    }\n    var projectId = getProjectId(options);\n    var parsed = functionsConfig.parseUnsetArgs(args);\n    return RSVP.all(_.map(parsed, function(item) {\n      if (item.varId === '') {\n        return runtimeconfig.configs.delete(projectId, item.configId);\n      }\n      return runtimeconfig.variables.delete(projectId, item.configId, item.varId);\n    })).then(function() {\n      utils.logSuccess('Environment updated.');\n      logger.info('\\nPlease deploy your functions for the change to take effect by running '\n        + chalk.bold('firebase deploy --only functions') + '\\n');\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/help.js":"'use strict';\n\nvar Command = require('../lib/command');\nvar RSVP = require('rsvp');\nvar chalk = require('chalk');\nvar logger = require('../lib/logger');\nvar utils = require('../lib/utils');\n\nmodule.exports = new Command('help [command]')\n  .description('display help information')\n  .action(function(commandName) {\n    var cmd = this.client.getCommand(commandName);\n    if (cmd) {\n      cmd.outputHelp();\n    } else if (commandName) {\n      logger.warn();\n      utils.logWarning(chalk.bold(commandName) + ' is not a valid command. See below for valid commands');\n      this.client.cli.outputHelp();\n    } else {\n      this.client.cli.outputHelp();\n      logger.info();\n      logger.info('  To get help with a specific command, type', chalk.bold('firebase help [command_name]'));\n      logger.info();\n    }\n\n    RSVP.resolve();\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/init.js":"'use strict';\n\nvar chalk = require('chalk');\nvar fs = require('fs');\nvar homeDir = require('user-home');\nvar path = require('path');\nvar RSVP = require('rsvp');\n\nvar Command = require('../lib/command');\nvar Config = require('../lib/config');\nvar init = require('../lib/init');\nvar logger = require('../lib/logger');\nvar prompt = require('../lib/prompt');\nvar requireAuth = require('../lib/requireAuth');\nvar utils = require('../lib/utils');\n\nvar BANNER_TEXT = fs.readFileSync(__dirname + '/../templates/banner.txt', 'utf8');\n\nvar _isOutside = function(from, to) {\n  return path.relative(from, to).match(/^\\.\\./);\n};\n\nmodule.exports = new Command('init [feature]')\n  .description('setup a Firebase project in the current directory')\n  .before(requireAuth)\n  .action(function(feature, options) {\n    var cwd = options.cwd || process.cwd();\n\n    var warnings = [];\n    var warningText = '';\n    if (_isOutside(homeDir, cwd)) {\n      warnings.push('You are currently outside your home directory');\n    }\n    if (cwd === homeDir) {\n      warnings.push('You are initializing your home directory as a Firebase project');\n    }\n\n    var config = Config.load(options, true);\n    var existingConfig = !!config;\n    if (!existingConfig) {\n      config = new Config({}, {projectDir: cwd, cwd: cwd});\n    } else {\n      warnings.push('You are initializing in an existing Firebase project directory');\n    }\n\n    if (warnings.length) {\n      warningText = '\\nBefore we get started, keep in mind:\\n\\n  ' + chalk.yellow.bold('* ') + warnings.join('\\n  ' + chalk.yellow.bold('* ')) + '\\n';\n    }\n\n    if (process.platform === 'darwin') {\n      BANNER_TEXT = BANNER_TEXT.replace(/#/g, '🔥');\n    }\n    logger.info(chalk.yellow.bold(BANNER_TEXT) +\n      '\\nYou\\'re about to initialize a Firebase project in this directory:\\n\\n  ' + chalk.bold(config.projectDir) + '\\n' +\n      warningText\n    );\n\n    var setup = {\n      config: config._src,\n      rcfile: config.readProjectFile('.firebaserc', {\n        json: true,\n        fallback: {}\n      })\n    };\n\n    var choices = [\n      {name: 'database', label: 'Database: Deploy Firebase Realtime Database Rules', checked: true},\n      {name: 'functions', label: 'Functions: Configure and deploy Cloud Functions', checked: true},\n      {name: 'hosting', label: 'Hosting: Configure and deploy Firebase Hosting sites', checked: true}\n      // {name: 'storage', label: 'Storage: Deploy Firebase Storage Security Rules', checked: true}\n    ];\n\n    var next;\n    // HACK: Windows Node has issues with selectables as the first prompt, so we\n    // add an extra confirmation prompt that fixes the problem\n    if (process.platform === 'win32') {\n      next = prompt.once({\n        type: 'confirm',\n        message: 'Are you ready to proceed?'\n      });\n    } else {\n      next = RSVP.resolve(true);\n    }\n\n    return next.then(function(proceed) {\n      if (!proceed) {\n        return utils.reject('Aborted by user.', {exit: 1});\n      }\n\n      if (feature) {\n        setup.featureArg = true;\n        setup.features = [feature];\n        return undefined;\n      }\n\n      return prompt(setup, [{\n        type: 'checkbox',\n        name: 'features',\n        message: 'What Firebase CLI features do you want to setup for this directory?',\n        choices: prompt.convertLabeledListChoices(choices)\n      }]);\n    }).then(function() {\n      if (!setup.featureArg) {\n        setup.features = setup.features.map(function(feat) {\n          return prompt.listLabelToValue(feat, choices);\n        });\n      }\n      setup.features.unshift('project');\n      return init(setup, config, options);\n    }).then(function() {\n      logger.info();\n      utils.logBullet('Writing configuration info to ' + chalk.bold('firebase.json') + '...');\n      config.writeProjectFile('firebase.json', setup.config);\n      utils.logBullet('Writing project information to ' + chalk.bold('.firebaserc') + '...');\n      config.writeProjectFile('.firebaserc', setup.rcfile);\n      logger.info();\n      utils.logSuccess('Firebase initialization complete!');\n\n      if (setup.createProject) {\n        logger.info();\n        logger.info(chalk.bold.cyan('Project creation is only available from the Firebase Console'));\n        logger.info('Please visit', chalk.underline('https://console.firebase.google.com'), 'to create a new project, then run', chalk.bold('firebase use --add'));\n      }\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/init/index.js":"'use strict';\n\nvar _ = require('lodash');\nvar chalk = require('chalk');\nvar RSVP = require('rsvp');\n\nvar logger = require('../logger');\nvar features = require('./features');\n\nvar init = function(setup, config, options) {\n  var nextFeature = setup.features.shift();\n  if (nextFeature) {\n    logger.info(chalk.bold('\\n' + chalk.gray('=== ') + _.capitalize(nextFeature) + ' Setup'));\n    return RSVP.resolve(features[nextFeature](setup, config, options)).then(function() {\n      return init(setup, config, options);\n    });\n  }\n  return RSVP.resolve();\n};\n\nmodule.exports = init;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/init/features/index.js":"'use strict';\n\nmodule.exports = {\n  database: require('./database'),\n  functions: require('./functions'),\n  hosting: require('./hosting'),\n  storage: require('./storage'),\n  // always runs, sets up .firebaserc\n  project: require('./project')\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/init/features/database.js":"'use strict';\n\nvar chalk = require('chalk');\nvar api = require('../../api');\nvar prompt = require('../../prompt');\nvar logger = require('../../logger');\nvar utils = require('../../utils');\nvar fsutils = require('../../fsutils');\nvar RSVP = require('rsvp');\n\nvar defaultRules = JSON.stringify({rules: {'.read': 'auth != null', '.write': 'auth != null'}}, null, 2);\n\nvar _getDBRules = function(instance) {\n  if (!instance) {\n    return RSVP.resolve(defaultRules);\n  }\n  return api.request('GET', '/.settings/rules.json', {\n    auth: true,\n    origin: utils.addSubdomain(api.realtimeOrigin, instance)\n  }).then(function(response) {\n    return response.body;\n  });\n};\n\nvar _writeDBRules = function(instance, filename, config) {\n  return _getDBRules(instance).then(function(rules) {\n    return config.writeProjectFile(filename, rules);\n  }).then(function() {\n    utils.logSuccess('Database Rules for ' + chalk.bold(instance) + ' have been downloaded to ' + chalk.bold(filename) + '.');\n    logger.info('Future modifications to ' + chalk.bold(filename) + ' will update Database Rules when you run');\n    logger.info(chalk.bold('firebase deploy') + '.');\n  });\n};\n\nmodule.exports = function(setup, config) {\n  setup.config.database = {};\n  var instance = setup.instance;\n  var filename = null;\n\n  logger.info();\n  logger.info('Firebase Realtime Database Rules allow you to define how your data should be');\n  logger.info('structured and when your data can be read from and written to.');\n  logger.info();\n\n  return prompt(setup.config.database, [\n    {\n      type: 'input',\n      name: 'rules',\n      message: 'What file should be used for Database Rules?',\n      default: 'database.rules.json'\n    }\n  ]).then(function() {\n    filename = setup.config.database.rules;\n\n    if (fsutils.fileExistsSync(filename)) {\n      var msg = 'File ' + chalk.bold(filename) + ' already exists.'\n        + ' Do you want to overwrite it with the Database Rules for ' + chalk.bold(instance)\n        + ' from the Firebase Console?';\n      return prompt.once({\n        type: 'confirm',\n        message: msg,\n        default: false\n      });\n    }\n    return RSVP.resolve(true);\n  }).then(function(overwrite) {\n    if (overwrite) {\n      return _writeDBRules(instance, filename, config);\n    }\n    logger.info('Skipping overwrite of Database Rules.');\n    logger.info('The rules defined in ' + chalk.bold(filename) + ' will be published when you do ' + chalk.bold('firebase deploy') + '.');\n    return RSVP.resolve();\n  });\n};\n\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/init/features/functions.js":"'use strict';\n\nvar chalk = require('chalk');\nvar fs = require('fs');\nvar RSVP = require('rsvp');\nvar spawn = require('cross-spawn');\nvar _ = require('lodash');\n\nvar logger = require('../../logger');\nvar prompt = require('../../prompt');\nvar enableApi = require('../../ensureApiEnabled').enable;\nvar requireAccess = require('../../requireAccess');\nvar scopes = require('../../scopes');\n\nvar INDEX_TEMPLATE = fs.readFileSync(__dirname + '/../../../templates/init/functions/index.js', 'utf8');\n\nmodule.exports = function(setup, config) {\n  logger.info();\n  logger.info('A ' + chalk.bold('functions') + ' directory will be created in your project with a Node.js');\n  logger.info('package pre-configured. Functions can be deployed with ' + chalk.bold('firebase deploy') + '.');\n  logger.info();\n\n  setup.functions = {};\n  var projectId = _.get(setup, 'rcfile.projects.default');\n  var enableApis;\n  if (projectId) {\n    enableApis = requireAccess({project: projectId}, [scopes.CLOUD_PLATFORM]).then(function() {\n      enableApi(projectId, 'cloudfunctions.googleapis.com');\n      enableApi(projectId, 'runtimeconfig.googleapis.com');\n    });\n  } else {\n    enableApis = RSVP.resolve();\n  }\n  return enableApis.then(function() {\n    return config.askWriteProjectFile('functions/package.json', {\n      name: 'functions',\n      description: 'Cloud Functions for Firebase',\n      dependencies: {\n        'firebase-admin': '~4.1.2',\n        'firebase-functions': '^0.5'\n      },\n      private: true\n    });\n  }).then(function() {\n    return config.askWriteProjectFile('functions/index.js', INDEX_TEMPLATE);\n  }).then(function() {\n    return prompt(setup.functions, [\n      {\n        name: 'npm',\n        type: 'confirm',\n        message: 'Do you want to install dependencies with npm now?',\n        default: true\n      }\n    ]);\n  }).then(function() {\n    if (setup.functions.npm) {\n      return new RSVP.Promise(function(resolve) {\n        var installer = spawn('npm', ['install'], {\n          cwd: config.projectDir + '/functions',\n          stdio: 'inherit'\n        });\n\n        installer.on('error', function(err) {\n          logger.debug(err.stack);\n        });\n\n        installer.on('close', function(code) {\n          if (code === 0) {\n            return resolve();\n          }\n          logger.info();\n          logger.error('NPM install failed, continuing with Firebase initialization...');\n          return resolve();\n        });\n      });\n    }\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/init/features/hosting.js":"'use strict';\n\nvar chalk = require('chalk');\nvar fs = require('fs');\nvar RSVP = require('rsvp');\n\nvar api = require('../../api');\nvar logger = require('../../logger');\nvar prompt = require('../../prompt');\n\nvar INDEX_TEMPLATE = fs.readFileSync(__dirname + '/../../../templates/init/hosting/index.html', 'utf8');\nvar MISSING_TEMPLATE = fs.readFileSync(__dirname + '/../../../templates/init/hosting/404.html', 'utf8');\nmodule.exports = function(setup, config) {\n  setup.hosting = {\n    ignore: [\n      'firebase.json',\n      '**/.*',\n      '**/node_modules/**'\n    ]\n  };\n\n  logger.info();\n  logger.info('Your ' + chalk.bold('public') + ' directory is the folder (relative to your project directory) that');\n  logger.info('will contain Hosting assets to be uploaded with ' + chalk.bold('firebase deploy') + '. If you');\n  logger.info('have a build process for your assets, use your build\\'s output directory.');\n  logger.info();\n\n  return prompt(setup.hosting, [\n    {\n      name: 'public',\n      type: 'input',\n      default: 'public',\n      message: 'What do you want to use as your public directory?'\n    },\n    {\n      name: 'spa',\n      type: 'confirm',\n      default: false,\n      message: 'Configure as a single-page app (rewrite all urls to /index.html)?'\n    }\n  ]).then(function() {\n    setup.config.hosting = {public: setup.hosting.public};\n\n    var next;\n    if (setup.hosting.spa) {\n      setup.config.hosting.rewrites = [\n        {source: '**', destination: '/index.html'}\n      ];\n      next = RSVP.resolve();\n    } else {\n      // SPA doesn't need a 404 page since everything is index.html\n      next = config.askWriteProjectFile(setup.hosting.public + '/404.html', MISSING_TEMPLATE);\n    }\n\n    return next.then(function() {\n      return api.request('GET', '/firebasejs/releases.json', {\n        origin: 'https://www.gstatic.com',\n        json: true\n      });\n    }).then(function(response) {\n      return config.askWriteProjectFile(setup.hosting.public + '/index.html', INDEX_TEMPLATE.replace(/{{VERSION}}/g, response.body.current.version));\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/init/features/storage.js":"'use strict';\n\nvar chalk = require('chalk');\nvar fs = require('fs');\n\nvar prompt = require('../../prompt');\nvar logger = require('../../logger');\n\nvar RULES_TEMPLATE = fs.readFileSync(__dirname + '/../../../templates/init/storage/storage.rules', 'utf8');\n\nmodule.exports = function(setup, config) {\n  setup.config.storage = {};\n\n  logger.info();\n  logger.info('Firebase Storage Security Rules allow you to define how and when to allow');\n  logger.info('uploads and downloads. You can keep these rules in your project directory');\n  logger.info('and publish them with ' + chalk.bold('firebase deploy') + '.');\n  logger.info();\n\n  return prompt(setup.config.storage, [\n    {\n      type: 'input',\n      name: 'rules',\n      message: 'What file should be used for Storage Rules?',\n      default: 'storage.rules'\n    }\n  ]).then(function() {\n    return config.writeProjectFile(setup.config.storage.rules, RULES_TEMPLATE);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/init/features/project.js":"'use strict';\n\nvar chalk = require('chalk');\n\nvar _ = require('lodash');\nvar api = require('../../api');\nvar prompt = require('../../prompt');\nvar logger = require('../../logger');\nvar utils = require('../../utils');\n\nvar NO_PROJECT = '[don\\'t setup a default project]';\nvar NEW_PROJECT = '[create a new project]';\n\nmodule.exports = function(setup, config) {\n  setup.project = {};\n\n  logger.info();\n  logger.info('First, let\\'s associate this project directory with a Firebase project.');\n  logger.info('You can create multiple project aliases by running ' + chalk.bold('firebase use --add') + ', ');\n  logger.info('but for now we\\'ll just set up a default project.');\n  logger.info();\n\n  return api.getProjects().then(function(projects) {\n    var choices = _.map(projects, function(info, projectId) {\n      return {\n        name: projectId,\n        label: info.name + ' (' + projectId + ')'\n      };\n    });\n    var nameOptions = [NO_PROJECT].concat(_.map(choices, 'label')).concat([NEW_PROJECT]);\n\n    if (_.has(setup.rcfile, 'projects.default')) {\n      utils.logBullet('.firebaserc already has a default project, skipping');\n      return undefined;\n    }\n\n    return prompt.once({\n      type: 'list',\n      name: 'id',\n      message: 'Select a default Firebase project for this directory:',\n      validate: function(answer) {\n        if (!_.includes(nameOptions, answer)) {\n          return 'Must specify a Firebase to which you have access.';\n        }\n        return true;\n      },\n      choices: nameOptions\n    }).then(function(projectId) {\n      if (projectId === NEW_PROJECT) {\n        setup.createProject = true;\n        return;\n      } else if (projectId === NO_PROJECT) {\n        return;\n      }\n      projectId = prompt.listLabelToValue(projectId, choices);\n      var instance = projects[projectId].instances.database[0];\n\n      // write \"default\" alias and activate it immediately\n      _.set(setup.rcfile, 'projects.default', projectId);\n      setup.instance = instance;\n      utils.makeActiveProject(config.projectDir, projectId);\n    });\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/list.js":"'use strict';\n\nvar Command = require('../lib/command');\nvar api = require('../lib/api');\nvar requireAuth = require('../lib/requireAuth');\nvar chalk = require('chalk');\nvar Table = require('cli-table');\nvar _ = require('lodash');\nvar logger = require('../lib/logger');\n\nmodule.exports = new Command('list')\n  .description('list the Firebases to which you have access')\n  .before(requireAuth)\n  .action(function(options) {\n    return api.getProjects().then(function(projects) {\n      var tableHead = ['Name', 'Project ID / Instance', 'Permissions'];\n      var table = new Table({\n        head: tableHead,\n        style: {head: ['yellow']}\n      });\n\n      var out = [];\n      _.forEach(projects, function(data, projectId) {\n        var project = {\n          name: data.name,\n          id: projectId,\n          permission: data.permission,\n          instance: data.instances.database[0]\n        };\n\n        var displayId = chalk.bold(projectId);\n        if (data.instances.database[0] !== projectId) {\n          displayId += '\\n' + data.instances.database[0] + ' (instance)';\n        }\n\n        var displayPermission;\n        switch (data.permission) {\n        case 'own':\n          displayPermission = chalk.cyan.bold('Owner');\n          break;\n        case 'edit':\n          displayPermission = chalk.bold('Editor');\n          break;\n        case 'view':\n        default:\n          displayPermission = 'Viewer';\n        }\n\n        var displayName = data.name;\n        if (options.project === projectId) {\n          displayName = chalk.cyan.bold(displayName + ' (current)');\n        }\n\n        out.push(project);\n        var row = [\n          displayName,\n          displayId,\n          displayPermission\n        ];\n        table.push(row);\n      });\n\n      if (_.size(projects) === 0) {\n        logger.info(chalk.bold('No projects found.'));\n        logger.info();\n        logger.info(\n          chalk.bold.cyan('Projects missing?') + ' This version of the Firebase CLI is only compatible with\\n' +\n          'projects that have been upgraded to the new Firebase Console. To access your\\n' +\n          'firebase.com apps, use a previous version: ' + chalk.bold('npm install -g firebase-tools@^2.1')\n        );\n      } else {\n        logger.info(table.toString());\n      }\n      return out;\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/login.js":"'use strict';\n\nvar Command = require('../lib/command');\nvar logger = require('../lib/logger');\nvar configstore = require('../lib/configstore');\nvar chalk = require('chalk');\nvar utils = require('../lib/utils');\nvar prompt = require('../lib/prompt');\nvar RSVP = require('rsvp');\nvar auth = require('../lib/auth');\n\nmodule.exports = new Command('login')\n  .description('log the CLI into Firebase')\n  .option('--no-localhost', 'copy and paste a code instead of starting a local server for authentication')\n  .option('--reauth', 'force reauthentication even if already logged in')\n  .action(function(options) {\n    if (options.nonInteractive) {\n      return utils.reject('Cannot run login in non-interactive mode. See ' +\n        chalk.bold('login:ci') + ' to generate a token for use in non-interactive environments.', {exit: 1});\n    }\n\n    var user = configstore.get('user');\n    var tokens = configstore.get('tokens');\n\n    if (user && tokens && !options.reauth) {\n      logger.info('Already logged in as', chalk.bold(user.email));\n      return RSVP.resolve(user);\n    }\n\n    return prompt(options, [{\n      type: 'confirm',\n      name: 'collectUsage',\n      message: 'Allow Firebase to collect anonymous CLI usage information?'\n    }]).then(function() {\n      configstore.set('usage', options.collectUsage);\n      return auth.login(options.localhost);\n    }).then(function(result) {\n      configstore.set('user', result.user);\n      configstore.set('tokens', result.tokens);\n      // store login scopes in case mandatory scopes grow over time\n      configstore.set('loginScopes', result.scopes);\n      // remove old session token, if it exists\n      configstore.del('session');\n\n      logger.info();\n      utils.logSuccess('Success! Logged in as ' + chalk.bold(result.user.email));\n\n      return auth;\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/auth.js":"'use strict';\n\nvar _ = require('lodash');\nvar chalk = require('chalk');\nvar fs = require('fs');\nvar jwt = require('jsonwebtoken');\nvar http = require('http');\nvar open = require('open');\nvar path = require('path');\nvar portfinder = require('portfinder');\nvar RSVP = require('rsvp');\nvar url = require('url');\n\nvar api = require('./api');\nvar configstore = require('./configstore');\nvar FirebaseError = require('./error');\nvar logger = require('./logger');\nvar prompt = require('./prompt');\nvar scopes = require('./scopes');\n\nportfinder.basePort = 9005;\n\nvar INVALID_CREDENTIAL_ERROR = new FirebaseError(\n  'Authentication Error: Your credentials are no longer valid. Please run ' + chalk.bold('firebase login --reauth') + '\\n\\n' +\n  'For CI servers and headless environments, generate a new token with ' + chalk.bold('firebase login:ci'),\n  {exit: 1}\n);\n\nvar FIFTEEN_MINUTES_IN_MS = 15 * 60 * 1000;\nvar SCOPES = [\n  scopes.EMAIL,\n  scopes.OPENID,\n  scopes.CLOUD_PROJECTS_READONLY,\n  scopes.FIREBASE_PLATFORM,\n  scopes.CLOUD_PLATFORM\n];\n\nvar _nonce = _.random(1, 2 << 29).toString();\nvar _getPort = RSVP.denodeify(portfinder.getPort);\n\n// in-memory cache, so we have it for successive calls\nvar lastAccessToken = {};\n\nvar _getCallbackUrl = function(port) {\n  if (_.isUndefined(port)) {\n    return 'urn:ietf:wg:oauth:2.0:oob';\n  }\n  return 'http://localhost:' + port;\n};\n\nvar _getLoginUrl = function(callbackUrl) {\n  return api.authOrigin + '/o/oauth2/auth?' + _.map({\n    client_id: api.clientId,\n    scope: SCOPES.join(' '),\n    response_type: 'code',\n    state: _nonce,\n    redirect_uri: callbackUrl\n  }, function(v, k) {\n    return k + '=' + encodeURIComponent(v);\n  }).join('&');\n};\n\nvar _getTokensFromAuthorizationCode = function(code, callbackUrl) {\n  return api.request('POST', '/o/oauth2/token', {\n    origin: api.authOrigin,\n    form: {\n      code: code,\n      client_id: api.clientId,\n      client_secret: api.clientSecret,\n      redirect_uri: callbackUrl,\n      grant_type: 'authorization_code'\n    }\n  }).then(function(res) {\n    if (!_.has(res, 'body.access_token') && !_.has(res, 'body.refresh_token')) {\n      throw INVALID_CREDENTIAL_ERROR;\n    }\n    lastAccessToken = _.assign({\n      expires_at: Date.now() + res.body.expires_in * 1000\n    }, res.body);\n    return lastAccessToken;\n  }, function() {\n    throw INVALID_CREDENTIAL_ERROR;\n  });\n};\n\nvar _respondWithFile = function(req, res, statusCode, filename) {\n  return new RSVP.Promise(function(resolve, reject) {\n    fs.readFile(path.join(__dirname, filename), function(err, response) {\n      if (err) {\n        return reject(err);\n      }\n      res.writeHead(statusCode, {\n        'Content-Length': response.length,\n        'Content-Type': 'text/html'\n      });\n      res.end(response);\n      req.socket.destroy();\n      return resolve();\n    });\n  });\n};\n\nvar _loginWithoutLocalhost = function() {\n  var callbackUrl = _getCallbackUrl();\n  var authUrl = _getLoginUrl(callbackUrl);\n\n  logger.info();\n  logger.info('Visit this URL on any device to log in:');\n  logger.info(chalk.bold.underline(authUrl));\n  logger.info();\n\n  open(authUrl);\n\n  return prompt({}, [{\n    type: 'input',\n    name: 'code',\n    message: 'Paste authorization code here:'\n  }]).then(function(answers) {\n    return _getTokensFromAuthorizationCode(answers.code, callbackUrl);\n  }).then(function(tokens) {\n    return {\n      user: jwt.decode(tokens.id_token),\n      tokens: tokens,\n      scopes: SCOPES\n    };\n  });\n};\n\nvar _loginWithLocalhost = function(port) {\n  return new RSVP.Promise(function(resolve, reject) {\n    var callbackUrl = _getCallbackUrl(port);\n    var authUrl = _getLoginUrl(callbackUrl);\n\n    var server = http.createServer(function(req, res) {\n      var tokens;\n      var query = _.get(url.parse(req.url, true), 'query', {});\n\n      if (query.state === _nonce && _.isString(query.code)) {\n        return _getTokensFromAuthorizationCode(query.code, callbackUrl)\n          .then(function(result) {\n            tokens = result;\n            return _respondWithFile(req, res, 200, '../templates/loginSuccess.html');\n          }).then(function() {\n            server.close();\n            return resolve({\n              user: jwt.decode(tokens.id_token),\n              tokens: tokens\n            });\n          }).catch(function() {\n            return _respondWithFile(req, res, 400, '../templates/loginFailure.html');\n          });\n      }\n      _respondWithFile(req, res, 400, '../templates/loginFailure.html');\n    });\n\n    server.listen(port, function() {\n      logger.info();\n      logger.info('Visit this URL on any device to log in:');\n      logger.info(chalk.bold.underline(authUrl));\n      logger.info();\n      logger.info('Waiting for authentication...');\n\n      open(authUrl);\n    });\n\n    server.on('error', function() {\n      _loginWithoutLocalhost().then(resolve, reject);\n    });\n  });\n};\n\nvar login = function(localhost) {\n  if (localhost) {\n    return _getPort().then(_loginWithLocalhost, _loginWithoutLocalhost);\n  }\n  return _loginWithoutLocalhost();\n};\n\nvar _haveValidAccessToken = function(refreshToken, authScopes) {\n  if (_.isEmpty(lastAccessToken)) {\n    var tokens = configstore.get('tokens');\n    if (refreshToken === _.get(tokens, 'refresh_token')) {\n      lastAccessToken = tokens;\n    }\n  }\n\n  return _.has(lastAccessToken, 'access_token') &&\n    lastAccessToken.refresh_token === refreshToken &&\n    // verify that the exact same scopes are being used for this request\n    _.isEqual(authScopes.sort(), (lastAccessToken.scopes || []).sort()) &&\n    _.has(lastAccessToken, 'expires_at') &&\n    lastAccessToken.expires_at > Date.now() + FIFTEEN_MINUTES_IN_MS;\n};\n\nvar _logoutCurrentSession = function(refreshToken) {\n  var tokens = configstore.get('tokens');\n  var currentToken = _.get(tokens, 'refresh_token');\n  if (refreshToken === currentToken) {\n    configstore.del('user');\n    configstore.del('tokens');\n    configstore.del('usage');\n    configstore.del('analytics-uuid');\n  }\n};\n\nvar _refreshAccessToken = function(refreshToken, authScopes) {\n  logger.debug('> refreshing access token with scopes:', JSON.stringify(authScopes));\n  return api.request('POST', '/oauth2/v3/token', {\n    origin: api.googleOrigin,\n    form: {\n      refresh_token: refreshToken,\n      client_id: api.clientId,\n      client_secret: api.clientSecret,\n      grant_type: 'refresh_token',\n      scope: (authScopes || []).join(' ')\n    }\n  }).then(function(res) {\n    if (!_.isString(res.body.access_token)) {\n      throw INVALID_CREDENTIAL_ERROR;\n    }\n    lastAccessToken = _.assign({\n      expires_at: Date.now() + res.body.expires_in * 1000,\n      refresh_token: refreshToken,\n      scopes: authScopes\n    }, res.body);\n\n    var currentRefreshToken = _.get(configstore.get('tokens'), 'refresh_token');\n    if (refreshToken === currentRefreshToken) {\n      configstore.set('tokens', lastAccessToken);\n    }\n\n    return lastAccessToken;\n  }, function(err) {\n    if (_.get(err, 'context.body.error') === 'invalid_scope') {\n      throw new FirebaseError(\n        'This command requires new authorization scopes not granted to your current session. Please run ' + chalk.bold('firebase login --reauth') + '\\n\\n' +\n        'For CI servers and headless environments, generate a new token with ' + chalk.bold('firebase login:ci'),\n        {exit: 1}\n      );\n    }\n\n    throw INVALID_CREDENTIAL_ERROR;\n  });\n};\n\nvar getAccessToken = function(refreshToken, authScopes) {\n  if (_haveValidAccessToken(refreshToken, authScopes)) {\n    return RSVP.resolve(lastAccessToken);\n  }\n  return _refreshAccessToken(refreshToken, authScopes);\n};\n\nvar logout = function(refreshToken) {\n  if (lastAccessToken.refresh_token === refreshToken) {\n    lastAccessToken = {};\n  }\n  _logoutCurrentSession(refreshToken);\n  return api.request('GET', '/o/oauth2/revoke', {\n    origin: api.authOrigin,\n    data: {\n      token: refreshToken\n    }\n  }, function() {\n    throw new FirebaseError('Authentication Error.', {\n      exit: 1\n    });\n  });\n};\n\nvar auth = {\n  login: login,\n  getAccessToken: getAccessToken,\n  logout: logout\n};\n\nmodule.exports = auth;\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/login-ci.js":"'use strict';\n\nvar Command = require('../lib/command');\nvar chalk = require('chalk');\nvar utils = require('../lib/utils');\nvar logger = require('../lib/logger');\nvar auth = require('../lib/auth');\n\nmodule.exports = new Command('login:ci')\n  .description('generate an access token for use in non-interactive environments')\n  .option('--no-localhost', 'copy and paste a code instead of starting a local server for authentication')\n  .action(function(options) {\n    if (options.nonInteractive) {\n      return utils.reject('Cannot run login:ci in non-interactive mode.', {exit: 1});\n    }\n\n    return auth.login(options.localhost).then(function(result) {\n      logger.info();\n      utils.logSuccess('Success! Use this token to login on a CI server:\\n\\n' +\n        chalk.bold(result.tokens.refresh_token) + '\\n\\nExample: firebase deploy --token \"$FIREBASE_TOKEN\"\\n');\n      return result;\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/logout.js":"'use strict';\n\nvar Command = require('../lib/command');\nvar configstore = require('../lib/configstore');\nvar logger = require('../lib/logger');\nvar chalk = require('chalk');\nvar RSVP = require('rsvp');\nvar utils = require('../lib/utils');\nvar api = require('../lib/api');\nvar auth = require('../lib/auth');\nvar _ = require('lodash');\n\nmodule.exports = new Command('logout')\n  .description('log the CLI out of Firebase')\n  .action(function(options) {\n    var user = configstore.get('user');\n    var tokens = configstore.get('tokens');\n    var currentToken = _.get(tokens, 'refresh_token');\n    var token = utils.getInheritedOption(options, 'token') || currentToken;\n    api.setToken(token);\n    var next;\n    if (token) {\n      next = auth.logout(token);\n    } else {\n      next = RSVP.resolve();\n    }\n\n    var cleanup = function() {\n      if (token || user || tokens) {\n        var msg = 'Logged out';\n        if (token === currentToken) {\n          if (user) {\n            msg += ' from ' + chalk.bold(user.email);\n          }\n        } else {\n          msg += ' token \"' + chalk.bold(token) + '\"';\n        }\n        utils.logSuccess(msg);\n      } else {\n        logger.info('No need to logout, not logged in');\n      }\n    };\n\n    return next.then(cleanup, function() {\n      utils.logWarning('Invalid refresh token, did not need to deauthorize');\n      cleanup();\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/open.js":"'use strict';\n\nvar _ = require('lodash');\nvar chalk = require('chalk');\nvar open = require('open');\nvar RSVP = require('rsvp');\n\nvar api = require('../lib/api');\nvar Command = require('../lib/command');\nvar logger = require('../lib/logger');\nvar prompt = require('../lib/prompt');\nvar requireAccess = require('../lib/requireAccess');\nvar utils = require('../lib/utils');\n\nvar LINKS = [\n  {name: 'Project Dashboard', arg: 'dashboard', consoleUrl: '/overview'},\n  {name: 'Analytics', arg: 'analytics', consoleUrl: '/analytics'},\n  {name: 'Database: Data', arg: 'database', consoleUrl: '/database/data'},\n  {name: 'Database: Rules', arg: 'database:rules', consoleUrl: '/database/rules'},\n  {name: 'Authentication: Providers', arg: 'auth', consoleUrl: '/authentication/providers'},\n  {name: 'Authentication: Users', arg: 'auth:users', consoleUrl: '/authentication/users'},\n  {name: 'Storage: Files', arg: 'storage', consoleUrl: '/storage/files'},\n  {name: 'Storage: Rules', arg: 'storage:rules', consoleUrl: '/storage/rules'},\n  {name: 'Hosting', arg: 'hosting', consoleUrl: '/hosting/main'},\n  {name: 'Hosting: Deployed Site', arg: 'hosting:site'},\n  {name: 'Remote Config', arg: 'config', consoleUrl: '/config'},\n  {name: 'Remote Config: Conditions', arg: 'config:conditions', consoleUrl: '/config/conditions'},\n  {name: 'Test Lab', arg: 'testlab', consoleUrl: '/testlab/histories/'},\n  {name: 'Crash Reporting', arg: 'crash', consoleUrl: '/monitoring'},\n  {name: 'Notifications', arg: 'notifications', consoleUrl: '/notification'},\n  {name: 'Dynamic Links', arg: 'links', consoleUrl: '/durablelinks'},\n  {name: 'Project Settings', arg: 'settings', consoleUrl: '/settings/general'},\n  {name: 'Docs', arg: 'docs', url: 'https://firebase.google.com/docs'},\n  {name: 'Functions Log', arg: 'functions:log'},\n  {name: 'Functions Dashboard', arg: 'functions'}\n];\n\nvar CHOICES = _.map(LINKS, 'name');\n\nmodule.exports = new Command('open [link]')\n  .description('quickly open a browser to relevant project resources')\n  .before(requireAccess)\n  .action(function(linkName, options) {\n    var link = _.find(LINKS, {arg: linkName});\n    if (linkName && !link) {\n      return utils.reject('Unrecognized link name. Valid links are:\\n\\n' + _.map(LINKS, 'arg').join('\\n'));\n    }\n\n    var next = RSVP.resolve(link);\n    if (!link) {\n      next = prompt.once({\n        type: 'list',\n        message: 'What link would you like to open?',\n        choices: CHOICES\n      }).then(function(result) {\n        return _.find(LINKS, {name: result});\n      });\n    }\n\n    return next.then(function(finalLink) {\n      var url;\n      if (finalLink.consoleUrl) {\n        url = utils.consoleUrl(options.project, finalLink.consoleUrl);\n      } else if (finalLink.url) {\n        url = finalLink.url;\n      } else if (finalLink.arg === 'hosting:site') {\n        url = utils.addSubdomain(api.hostingOrigin, options.instance);\n      } else if (finalLink.arg === 'functions') {\n        url = 'https://console.firebase.google.com/project/' + options.project + '/functions/list';\n      } else if (finalLink.arg === 'functions:log') {\n        url = 'https://console.developers.google.com/logs/viewer?resource=cloudfunctions.googleapis.com&project=' + options.project;\n      }\n\n      if (finalLink.arg !== linkName) {\n        logger.info(chalk.bold.cyan('Tip: ') + 'You can also run ' + chalk.bold.underline('firebase open ' + finalLink.arg));\n        logger.info();\n      }\n      logger.info('Opening ' + chalk.bold(finalLink.name) + ' link in your default browser:');\n      logger.info(chalk.bold.underline(url));\n\n      open(url);\n      return RSVP.resolve(url);\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/serve.js":"'use strict';\n\nvar chalk = require('chalk');\nvar RSVP = require('rsvp');\nvar superstatic = require('superstatic').server;\n\nvar Command = require('../lib/command');\nvar detectProjectRoot = require('../lib/detectProjectRoot');\nvar FirebaseError = require('../lib/error');\nvar hostingImplicitInit = require('../lib/hostingImplicitInit');\nvar hostingInitMiddleware = require('../lib/hostingInitMiddleware');\nvar logger = require('../lib/logger');\nvar utils = require('../lib/utils');\nvar requireAccess = require('../lib/requireAccess');\nvar requireConfig = require('../lib/requireConfig');\nvar checkDupHostingKeys = require('../lib/checkDupHostingKeys');\nvar scopes = require('../lib/scopes');\n\nvar MAX_PORT_ATTEMPTS = 10;\n\nvar _attempts = 0;\nvar startServer = function(options) {\n  var config = options.config ? options.config.get('hosting') : {public: '.'};\n\n  return hostingImplicitInit(options).then(function(init) {\n    var server = superstatic({\n      debug: true,\n      port: options.port,\n      host: options.host,\n      config: config,\n      cwd: detectProjectRoot(options.cwd),\n      stack: 'strict',\n      before: {\n        files: hostingInitMiddleware(init)\n      }\n    }).listen(function() {\n      if (config.public && config.public !== '.') {\n        logger.info(chalk.bold('Public Directory:'), config.public);\n      }\n      logger.info();\n      logger.info('Server listening at: ' + chalk.underline(chalk.bold('http://' + options.host + ':' + options.port)));\n    });\n\n    server.on('error', function(err) {\n      if (err.code === 'EADDRINUSE') {\n        var message = 'Port ' + options.port + ' is not available.';\n        if (_attempts < MAX_PORT_ATTEMPTS) {\n          utils.logWarning(message + ' Trying another port...');\n          options.port++;\n          _attempts++;\n          startServer(options);\n        } else {\n          utils.logWarning(message);\n          throw new FirebaseError('Could not find an open port for development server.', {exit: 1});\n        }\n      } else {\n        throw new FirebaseError('An error occurred while starting the development server:\\n\\n' + err.toString(), {exit: 1});\n      }\n    });\n  });\n};\n\nmodule.exports = new Command('serve')\n  .description('start a local server for your static assets')\n  .option('-p, --port <port>', 'the port on which to listen (default: 5000)', 5000)\n  .option('-o, --host <host>', 'the host on which to listen (default: localhost)', 'localhost')\n  .before(requireConfig)\n  .before(requireAccess, [scopes.CLOUD_PLATFORM])\n  .before(checkDupHostingKeys)\n  .action(function(options) {\n    logger.info('Starting Firebase development server...');\n    logger.info();\n\n    if (options.config) {\n      logger.info(chalk.bold('Project Directory:'), options.config.projectDir);\n    } else {\n      utils.logWarning('No Firebase project directory detected. Serving static content from ' + chalk.bold(options.cwd || process.cwd()));\n    }\n\n    return startServer(options).then(function() {\n      return new RSVP.Promise(function(resolve) {\n        process.on('SIGINT', function() {\n          logger.info('Shutting down...');\n          resolve();\n        });\n      });\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/hostingImplicitInit.js":"'use strict';\n\nvar fs = require('fs');\n\nvar fetchWebSetup = require('./fetchWebSetup');\n\nvar INIT_TEMPLATE = fs.readFileSync(__dirname + '/../templates/hosting/init.js', 'utf8');\n\nmodule.exports = function(options) {\n  return fetchWebSetup(options).then(function(config) {\n    var configJson = JSON.stringify(config, null, 2);\n    return {\n      js: INIT_TEMPLATE.replace('{/*--CONFIG--*/}', configJson),\n      json: configJson\n    };\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/fetchWebSetup.js":"'use strict';\n\nvar getProjectId = require('./getProjectId');\nvar api = require('./api');\n\nmodule.exports = function(options) {\n  var projectId = getProjectId(options);\n  return api.request('GET', '/v1/projects/' + projectId, {\n    auth: true,\n    origin: api.resourceManagerOrigin\n  }).then(function(response) {\n    return api.request('GET', '/v1/projects/' + response.body.projectNumber + '/clients/_:getWebAppConfig', {\n      auth: true,\n      origin: api.firedataOrigin\n    });\n  }).then(function(response) {\n    return response.body;\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/lib/hostingInitMiddleware.js":"'use strict';\n\nvar request = require('request');\n\nvar SDK_PATH_REGEXP = /^\\/__\\/firebase\\/([^/]+)\\/([^/]+)$/;\n\nmodule.exports = function(init) {\n  return function(req, res, next) {\n    var match = req.url.match(SDK_PATH_REGEXP);\n    if (match) {\n      var url = 'https://www.gstatic.com/firebasejs/' + match[1] + '/' + match[2];\n      var preq = request(url).on('response', function(pres) {\n        if (pres.statusCode === 404) {\n          return next();\n        }\n        return preq.pipe(res);\n      });\n    } else if (req.url === '/__/firebase/init.js') {\n      res.setHeader('Content-Type', 'application/javascript');\n      res.end(init.js);\n    } else if (req.url === '/__/firebase/init.json') {\n      res.setHeader('Content-Type', 'application/json');\n      res.end(init.json);\n    } else {\n      next();\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/setup-web.js":"'use strict';\n\nvar fs = require('fs');\nvar RSVP = require('rsvp');\n\nvar Command = require('../lib/command');\nvar fetchWebSetup = require('../lib/fetchWebSetup');\nvar logger = require('../lib/logger');\nvar requireAccess = require('../lib/requireAccess');\nvar scopes = require('../lib/scopes');\n\nvar JS_TEMPLATE = fs.readFileSync(__dirname + '/../templates/setup/web.js', 'utf8');\n\nmodule.exports = new Command('setup:web')\n  .description('display this project\\'s setup information for the Firebase JS SDK')\n  .before(requireAccess, [scopes.CLOUD_PLATFORM])\n  .action(function(options) {\n    return fetchWebSetup(options).then(function(config) {\n      logger.info(JS_TEMPLATE.replace('{/*--CONFIG--*/}', JSON.stringify(config, null, 2)));\n      return RSVP.resolve(config);\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/tools-migrate.js":"'use strict';\n\nvar _ = require('lodash');\nvar chalk = require('chalk');\nvar RSVP = require('rsvp');\n\nvar Command = require('../lib/command');\nvar Config = require('../lib/config');\nvar identifierToProjectId = require('../lib/identifierToProjectId');\nvar logger = require('../lib/logger');\nvar prompt = require('../lib/prompt');\nvar requireAuth = require('../lib/requireAuth');\nvar utils = require('../lib/utils');\n\nvar MOVE_KEYS = {\n  rules: 'database.rules'\n};\nConfig.LEGACY_HOSTING_KEYS.forEach(function(key) {\n  MOVE_KEYS[key] = 'hosting.' + key;\n});\n\nmodule.exports = new Command('tools:migrate')\n  .description('ensure your firebase.json format is up to date')\n  .option('-y, --confirm', 'pass this option to bypass confirmation prompt')\n  .before(requireAuth)\n  .action(function(options) {\n    if (!options.config) {\n      return utils.reject('Must run ' + chalk.bold('tools:migrate') + ' from a directory with a firebase.json');\n    }\n\n    utils.logBullet('Checking feature configuration...');\n    var out = _.cloneDeep(options.config._src);\n    var changed = false;\n\n    _.forEach(MOVE_KEYS, function(dest, src) {\n      if (_.has(out, src)) {\n        _.set(out, dest, _.get(out, src));\n        _.unset(out, src);\n        changed = true;\n      }\n    });\n\n    utils.logBullet('Checking \"firebase\" key...');\n    var instance = out.firebase;\n    var rcfile;\n    var next;\n    var projectId;\n    if (instance) {\n      next = identifierToProjectId(instance).then(function(result) {\n        projectId = result;\n        if (projectId) {\n          rcfile = {projects: {default: projectId}};\n          _.unset(out, 'firebase');\n        } else {\n          return utils.reject('Could not find Firebase project corresponding to ' + chalk.bold(instance) + '.\\nPlease ensure it has been migrated to the new console before proceeding.');\n        }\n      });\n      rcfile = {projects: {default: instance}};\n\n      changed = true;\n    } else {\n      next = RSVP.resolve();\n    }\n\n    return next.then(function() {\n      if (!changed) {\n        logger.info();\n        utils.logSuccess('No action required, your firebase.json is all up to date!');\n        return true;\n      }\n\n      logger.info();\n      logger.info(chalk.gray.bold('# preview: updated contents of firebase.json'));\n      logger.info();\n      logger.info(JSON.stringify(out, null, 2));\n      logger.info();\n\n      if (options.confirm) {\n        next = RSVP.resolve(true);\n      } else {\n        next = prompt.once({\n          type: 'confirm',\n          message: 'Write new config to ' + chalk.underline('firebase.json') + '?',\n          default: true\n        });\n      }\n\n      return next.then(function(confirmed) {\n        if (confirmed) {\n          options.config.writeProjectFile('firebase.json', out);\n          utils.logSuccess('Migrated ' + chalk.bold('firebase.json') + ' successfully');\n          if (projectId) {\n            options.config.writeProjectFile('.firebaserc', rcfile);\n            utils.makeActiveProject(options.projectRoot, projectId);\n            utils.logSuccess('Set default project to ' + chalk.bold(projectId));\n          }\n        } else {\n          return utils.reject('Migration aborted by user.', {exit: 1});\n        }\n      });\n    });\n  });\n","/home/travis/build/npmtest/node-npmtest-firebase-tools/node_modules/firebase-tools/commands/use.js":"'use strict';\n\nvar Command = require('../lib/command');\nvar logger = require('../lib/logger');\nvar requireAuth = require('../lib/requireAuth');\nvar api = require('../lib/api');\nvar chalk = require('chalk');\nvar utils = require('../lib/utils');\nvar _ = require('lodash');\nvar fs = require('fs');\nvar path = require('path');\nvar prompt = require('../lib/prompt');\n\nvar writeAlias = function(projectDir, rc, alias, projectId) {\n  if (projectId) {\n    _.set(rc, ['projects', alias], projectId);\n  } else {\n    _.unset(rc, ['projects', alias], projectId);\n  }\n  fs.writeFileSync(path.resolve(projectDir, './.firebaserc'), JSON.stringify(rc, null, 2));\n};\n\nvar listAliases = function(options) {\n  if (_.size(options.rc, 'projects') > 0) {\n    logger.info('Project aliases for', chalk.bold(options.projectRoot) + ':');\n    logger.info();\n    _.forEach(options.rc.projects, function(projectId, alias) {\n      var listing = alias + ' (' + projectId + ')';\n      if (options.project === projectId || options.projectAlias === alias) {\n        logger.info(chalk.cyan.bold('* ' + listing));\n      } else {\n        logger.info('  ' + listing);\n      }\n    });\n    logger.info();\n  }\n  logger.info('Run', chalk.bold('firebase use --add'), 'to define a new project alias.');\n};\n\nvar verifyMessage = function(name) {\n  return 'please verify project ' + chalk.bold(name) + ' exists and you have access.';\n};\n\nmodule.exports = new Command('use [alias_or_project_id]')\n  .description('set an active Firebase project for your working directory')\n  .option('--add', 'create a new project alias interactively')\n  .option('--alias <name>', 'create a new alias for the provided project id')\n  .option('--unalias <name>', 'remove an already created project alias')\n  .option('--clear', 'clear the active project selection')\n  .before(requireAuth)\n  .action(function(newActive, options) {\n    // HACK: Commander.js silently swallows an option called alias >_<\n    var aliasOpt;\n    var i = process.argv.indexOf('--alias');\n    if (i >= 0 && process.argv.length > i + 1) {\n      aliasOpt = process.argv[i + 1];\n    }\n\n    if (!options.projectRoot) { // not in project directory\n      return utils.reject(chalk.bold('firebase use') + ' must be run from a Firebase project directory.\\n\\nRun ' + chalk.bold('firebase init') + ' to start a project directory in the current folder.');\n    }\n\n    if (newActive) { // firebase use [alias_or_project]\n      var aliasedProject = _.get(options.rc, ['projects', newActive]);\n      return api.getProjects().then(function(projects) {\n        if (aliasOpt) { // firebase use [project] --alias [alias]\n          if (!projects[newActive]) {\n            return utils.reject('Cannot create alias ' + chalk.bold(aliasOpt) + ', ' + verifyMessage(newActive));\n          }\n          writeAlias(options.projectRoot, options.rc, aliasOpt, newActive);\n          aliasedProject = newActive;\n          logger.info('Created alias', chalk.bold(aliasOpt), 'for', aliasedProject + '.');\n        }\n\n        if (aliasedProject) { // found alias\n          if (!projects[aliasedProject]) { // found alias, but not in project list\n            return utils.reject('Unable to use alias ' + chalk.bold(newActive) + ', ' + verifyMessage(aliasedProject));\n          }\n\n          utils.makeActiveProject(options.projectRoot, newActive);\n          logger.info('Now using alias', chalk.bold(newActive), '(' + aliasedProject + ')');\n        } else if (projects[newActive]) { // exact project id specified\n          utils.makeActiveProject(options.projectRoot, newActive);\n          logger.info('Now using project', chalk.bold(newActive));\n        } else { // no alias or project recognized\n          return utils.reject('Invalid project selection, ' + verifyMessage(newActive));\n        }\n      });\n    } else if (options.unalias) { // firebase use --unalias [alias]\n      if (_.has(options.rc, ['projects', options.unalias])) {\n        writeAlias(options.projectRoot, options.rc, options.unalias, null);\n        logger.info('Removed alias', chalk.bold(options.unalias));\n        logger.info();\n        listAliases(options);\n      }\n    } else if (options.add) { // firebase use --add\n      if (options.nonInteractive) {\n        return utils.reject('Cannot run ' + chalk.bold('firebase use --add') + ' in non-interactive mode. Use ' + chalk.bold('firebase use <project_id> --alias <alias>') + ' instead.');\n      }\n      return api.getProjects().then(function(projects) {\n        var results = {};\n        return prompt(results, [\n          {\n            type: 'list',\n            name: 'project',\n            message: 'Which project do you want to add?',\n            choices: Object.keys(projects).sort()\n          },\n          {\n            type: 'input',\n            name: 'alias',\n            message: 'What alias do you want to use for this project? (e.g. staging)',\n            validate: function(input) {\n              return input && input.length > 0;\n            }\n          }\n        ]).then(function() {\n          writeAlias(options.projectRoot, options.rc, results.alias, results.project);\n          utils.makeActiveProject(options.projectRoot, results.alias);\n          logger.info();\n          logger.info('Created alias', chalk.bold(results.alias), 'for', results.project + '.');\n          logger.info('Now using alias', chalk.bold(results.alias) + ' (' + results.project + ')');\n        });\n      });\n    } else if (options.clear) { // firebase use --clear\n      utils.makeActiveProject(options.projectRoot, null);\n      options.projectAlias = null;\n      options.project = null;\n      logger.info('Cleared active project.');\n      logger.info();\n      listAliases(options);\n    } else { // firebase use\n      if (!process.stdout.isTTY) {\n        if (options.project) {\n          logger.info(options.project);\n          return options.project;\n        }\n        return utils.reject('No active project', {exit: 1});\n      }\n\n      if (options.projectAlias) {\n        logger.info('Active Project:', chalk.bold.cyan(options.projectAlias + ' (' + options.project + ')'));\n      } else if (options.project) {\n        logger.info('Active Project:', chalk.bold.cyan(options.project));\n      } else {\n        var msg = 'No project is currently active';\n        if (_.size(options.rc.projects === 0)) {\n          msg += ', and no aliases have been created.';\n        }\n        logger.info(msg + '.');\n      }\n      logger.info();\n      listAliases(options);\n    }\n  });\n"}